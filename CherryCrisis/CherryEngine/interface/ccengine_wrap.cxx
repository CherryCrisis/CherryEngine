/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGCSHARP
#define SWIGCSHARP
#endif

#define SWIG_DIRECTORS


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#include <stdlib.h>
#include <string.h>
#include <stdio.h>


/* Support for throwing C# exceptions from C/C++. There are two types: 
 * Exceptions that take a message and ArgumentExceptions that take a message and a parameter name. */
typedef enum {
  SWIG_CSharpApplicationException,
  SWIG_CSharpArithmeticException,
  SWIG_CSharpDivideByZeroException,
  SWIG_CSharpIndexOutOfRangeException,
  SWIG_CSharpInvalidCastException,
  SWIG_CSharpInvalidOperationException,
  SWIG_CSharpIOException,
  SWIG_CSharpNullReferenceException,
  SWIG_CSharpOutOfMemoryException,
  SWIG_CSharpOverflowException,
  SWIG_CSharpSystemException
} SWIG_CSharpExceptionCodes;

typedef enum {
  SWIG_CSharpArgumentException,
  SWIG_CSharpArgumentNullException,
  SWIG_CSharpArgumentOutOfRangeException
} SWIG_CSharpExceptionArgumentCodes;

typedef void (SWIGSTDCALL* SWIG_CSharpExceptionCallback_t)(const char *);
typedef void (SWIGSTDCALL* SWIG_CSharpExceptionArgumentCallback_t)(const char *, const char *);

typedef struct {
  SWIG_CSharpExceptionCodes code;
  SWIG_CSharpExceptionCallback_t callback;
} SWIG_CSharpException_t;

typedef struct {
  SWIG_CSharpExceptionArgumentCodes code;
  SWIG_CSharpExceptionArgumentCallback_t callback;
} SWIG_CSharpExceptionArgument_t;

static SWIG_CSharpException_t SWIG_csharp_exceptions[] = {
  { SWIG_CSharpApplicationException, NULL },
  { SWIG_CSharpArithmeticException, NULL },
  { SWIG_CSharpDivideByZeroException, NULL },
  { SWIG_CSharpIndexOutOfRangeException, NULL },
  { SWIG_CSharpInvalidCastException, NULL },
  { SWIG_CSharpInvalidOperationException, NULL },
  { SWIG_CSharpIOException, NULL },
  { SWIG_CSharpNullReferenceException, NULL },
  { SWIG_CSharpOutOfMemoryException, NULL },
  { SWIG_CSharpOverflowException, NULL },
  { SWIG_CSharpSystemException, NULL }
};

static SWIG_CSharpExceptionArgument_t SWIG_csharp_exceptions_argument[] = {
  { SWIG_CSharpArgumentException, NULL },
  { SWIG_CSharpArgumentNullException, NULL },
  { SWIG_CSharpArgumentOutOfRangeException, NULL }
};

static void SWIGUNUSED SWIG_CSharpSetPendingException(SWIG_CSharpExceptionCodes code, const char *msg) {
  SWIG_CSharpExceptionCallback_t callback = SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions)/sizeof(SWIG_CSharpException_t)) {
    callback = SWIG_csharp_exceptions[code].callback;
  }
  callback(msg);
}

static void SWIGUNUSED SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpExceptionArgumentCodes code, const char *msg, const char *param_name) {
  SWIG_CSharpExceptionArgumentCallback_t callback = SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions_argument)/sizeof(SWIG_CSharpExceptionArgument_t)) {
    callback = SWIG_csharp_exceptions_argument[code].callback;
  }
  callback(msg, param_name);
}


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionCallbacks_CherryEngine(
                                                SWIG_CSharpExceptionCallback_t applicationCallback,
                                                SWIG_CSharpExceptionCallback_t arithmeticCallback,
                                                SWIG_CSharpExceptionCallback_t divideByZeroCallback, 
                                                SWIG_CSharpExceptionCallback_t indexOutOfRangeCallback, 
                                                SWIG_CSharpExceptionCallback_t invalidCastCallback,
                                                SWIG_CSharpExceptionCallback_t invalidOperationCallback,
                                                SWIG_CSharpExceptionCallback_t ioCallback,
                                                SWIG_CSharpExceptionCallback_t nullReferenceCallback,
                                                SWIG_CSharpExceptionCallback_t outOfMemoryCallback, 
                                                SWIG_CSharpExceptionCallback_t overflowCallback, 
                                                SWIG_CSharpExceptionCallback_t systemCallback) {
  SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback = applicationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpArithmeticException].callback = arithmeticCallback;
  SWIG_csharp_exceptions[SWIG_CSharpDivideByZeroException].callback = divideByZeroCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIndexOutOfRangeException].callback = indexOutOfRangeCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidCastException].callback = invalidCastCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidOperationException].callback = invalidOperationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIOException].callback = ioCallback;
  SWIG_csharp_exceptions[SWIG_CSharpNullReferenceException].callback = nullReferenceCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOutOfMemoryException].callback = outOfMemoryCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOverflowException].callback = overflowCallback;
  SWIG_csharp_exceptions[SWIG_CSharpSystemException].callback = systemCallback;
}

#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionArgumentCallbacks_CherryEngine(
                                                SWIG_CSharpExceptionArgumentCallback_t argumentCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentNullCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentOutOfRangeCallback) {
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback = argumentCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentNullException].callback = argumentNullCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentOutOfRangeException].callback = argumentOutOfRangeCallback;
}


/* Callback for returning strings to C# without leaking memory */
typedef char * (SWIGSTDCALL* SWIG_CSharpStringHelperCallback)(const char *);
static SWIG_CSharpStringHelperCallback SWIG_csharp_string_callback = NULL;


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterStringCallback_CherryEngine(SWIG_CSharpStringHelperCallback callback) {
  SWIG_csharp_string_callback = callback;
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, msg, ""); return nullreturn; } else

/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that C# proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#if defined(DEBUG_DIRECTOR_OWNED)
#include <iostream>
#endif
#include <string>
#include <exception>

namespace Swig {
  /* Director base class - not currently used in C# directors */
  class Director {
  };

  /* Base class for director exceptions */
  class DirectorException : public std::exception {
  protected:
    std::string swig_msg;

  public:
    DirectorException(const char *msg) : swig_msg(msg) {
    }

    DirectorException(const std::string &msg) : swig_msg(msg) {
    }

    virtual ~DirectorException() throw() {
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }
  };

  /* Pure virtual method exception */
  class DirectorPureVirtualException : public DirectorException {
  public:
    DirectorPureVirtualException(const char *msg) : DirectorException(std::string("Attempt to invoke pure virtual method ") + msg) {
    }

    static void raise(const char *msg) {
      throw DirectorPureVirtualException(msg);
    }
  };
}


	#include "maths/maths_utils.hpp"

	using namespace CCMaths;


	#include "maths/vector2.hpp"


	#include "maths/vector3.hpp"


	#include "maths/vector4.hpp"


	#include "maths/matrix4.hpp"


	#include "maths/quaternion.hpp"


	#include "singleton.hpp"
	#include "physic_manager.hpp"

	using namespace PhysicSystem;


	#include "behaviour.hpp"
	#include "object.hpp"


	#include "object.hpp"


	#include "entity.hpp"
	#include "object.hpp"


#include <string>


#include <typeinfo>
#include <stdexcept>


#include <vector>
#include <algorithm>
#include <stdexcept>


	#include "transform.hpp"
	#include "behaviour.hpp"
	#include "maths.hpp"


	#include "behaviour.hpp"
	#include "object.hpp"


	#include "camera_component.hpp"


	#include "scripted_behaviour.hpp"
	#include "behaviour.hpp"


	#include "mesh_renderer.hpp"


	#include "behaviour.hpp"
	#include "maths.hpp"


	#include "mesh.hpp"


	#include "material.hpp"
	#include "maths.hpp"


	#include "texture.hpp"

SWIGINTERN std::vector< CameraComponent * > *new_std_vector_Sl_CameraComponent_Sm__Sg___SWIG_2(int capacity){
        std::vector< CameraComponent * >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< CameraComponent * >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN CameraComponent *std_vector_Sl_CameraComponent_Sm__Sg__getitemcopy(std::vector< CameraComponent * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< CameraComponent * >::value_type const &std_vector_Sl_CameraComponent_Sm__Sg__getitem(std::vector< CameraComponent * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CameraComponent_Sm__Sg__setitem(std::vector< CameraComponent * > *self,int index,CameraComponent *const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CameraComponent_Sm__Sg__AddRange(std::vector< CameraComponent * > *self,std::vector< CameraComponent * > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< CameraComponent * > *std_vector_Sl_CameraComponent_Sm__Sg__GetRange(std::vector< CameraComponent * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< CameraComponent * >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CameraComponent_Sm__Sg__Insert(std::vector< CameraComponent * > *self,int index,CameraComponent *const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CameraComponent_Sm__Sg__InsertRange(std::vector< CameraComponent * > *self,int index,std::vector< CameraComponent * > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CameraComponent_Sm__Sg__RemoveAt(std::vector< CameraComponent * > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_CameraComponent_Sm__Sg__RemoveRange(std::vector< CameraComponent * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< CameraComponent * > *std_vector_Sl_CameraComponent_Sm__Sg__Repeat(CameraComponent *const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< CameraComponent * >(count, value);
      }
SWIGINTERN void std_vector_Sl_CameraComponent_Sm__Sg__Reverse__SWIG_0(std::vector< CameraComponent * > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_CameraComponent_Sm__Sg__Reverse__SWIG_1(std::vector< CameraComponent * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_CameraComponent_Sm__Sg__SetRange(std::vector< CameraComponent * > *self,int index,std::vector< CameraComponent * > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_CameraComponent_Sm__Sg__Contains(std::vector< CameraComponent * > *self,CameraComponent *const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_CameraComponent_Sm__Sg__IndexOf(std::vector< CameraComponent * > *self,CameraComponent *const &value){
        int index = -1;
        std::vector< CameraComponent * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_CameraComponent_Sm__Sg__LastIndexOf(std::vector< CameraComponent * > *self,CameraComponent *const &value){
        int index = -1;
        std::vector< CameraComponent * >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_CameraComponent_Sm__Sg__Remove(std::vector< CameraComponent * > *self,CameraComponent *const &value){
        std::vector< CameraComponent * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
          return true;
        }
        return false;
      }
SWIGINTERN std::vector< Transform * > *new_std_vector_Sl_Transform_Sm__Sg___SWIG_2(int capacity){
        std::vector< Transform * >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< Transform * >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN Transform *std_vector_Sl_Transform_Sm__Sg__getitemcopy(std::vector< Transform * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< Transform * >::value_type const &std_vector_Sl_Transform_Sm__Sg__getitem(std::vector< Transform * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Transform_Sm__Sg__setitem(std::vector< Transform * > *self,int index,Transform *const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Transform_Sm__Sg__AddRange(std::vector< Transform * > *self,std::vector< Transform * > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< Transform * > *std_vector_Sl_Transform_Sm__Sg__GetRange(std::vector< Transform * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< Transform * >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Transform_Sm__Sg__Insert(std::vector< Transform * > *self,int index,Transform *const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Transform_Sm__Sg__InsertRange(std::vector< Transform * > *self,int index,std::vector< Transform * > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Transform_Sm__Sg__RemoveAt(std::vector< Transform * > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Transform_Sm__Sg__RemoveRange(std::vector< Transform * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< Transform * > *std_vector_Sl_Transform_Sm__Sg__Repeat(Transform *const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< Transform * >(count, value);
      }
SWIGINTERN void std_vector_Sl_Transform_Sm__Sg__Reverse__SWIG_0(std::vector< Transform * > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_Transform_Sm__Sg__Reverse__SWIG_1(std::vector< Transform * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Transform_Sm__Sg__SetRange(std::vector< Transform * > *self,int index,std::vector< Transform * > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_Transform_Sm__Sg__Contains(std::vector< Transform * > *self,Transform *const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_Transform_Sm__Sg__IndexOf(std::vector< Transform * > *self,Transform *const &value){
        int index = -1;
        std::vector< Transform * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_Transform_Sm__Sg__LastIndexOf(std::vector< Transform * > *self,Transform *const &value){
        int index = -1;
        std::vector< Transform * >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_Transform_Sm__Sg__Remove(std::vector< Transform * > *self,Transform *const &value){
        std::vector< Transform * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
          return true;
        }
        return false;
      }
SWIGINTERN std::vector< ScriptedBehaviour * > *new_std_vector_Sl_ScriptedBehaviour_Sm__Sg___SWIG_2(int capacity){
        std::vector< ScriptedBehaviour * >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< ScriptedBehaviour * >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN ScriptedBehaviour *std_vector_Sl_ScriptedBehaviour_Sm__Sg__getitemcopy(std::vector< ScriptedBehaviour * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< ScriptedBehaviour * >::value_type const &std_vector_Sl_ScriptedBehaviour_Sm__Sg__getitem(std::vector< ScriptedBehaviour * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_ScriptedBehaviour_Sm__Sg__setitem(std::vector< ScriptedBehaviour * > *self,int index,ScriptedBehaviour *const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_ScriptedBehaviour_Sm__Sg__AddRange(std::vector< ScriptedBehaviour * > *self,std::vector< ScriptedBehaviour * > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< ScriptedBehaviour * > *std_vector_Sl_ScriptedBehaviour_Sm__Sg__GetRange(std::vector< ScriptedBehaviour * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< ScriptedBehaviour * >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_ScriptedBehaviour_Sm__Sg__Insert(std::vector< ScriptedBehaviour * > *self,int index,ScriptedBehaviour *const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_ScriptedBehaviour_Sm__Sg__InsertRange(std::vector< ScriptedBehaviour * > *self,int index,std::vector< ScriptedBehaviour * > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_ScriptedBehaviour_Sm__Sg__RemoveAt(std::vector< ScriptedBehaviour * > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_ScriptedBehaviour_Sm__Sg__RemoveRange(std::vector< ScriptedBehaviour * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< ScriptedBehaviour * > *std_vector_Sl_ScriptedBehaviour_Sm__Sg__Repeat(ScriptedBehaviour *const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< ScriptedBehaviour * >(count, value);
      }
SWIGINTERN void std_vector_Sl_ScriptedBehaviour_Sm__Sg__Reverse__SWIG_0(std::vector< ScriptedBehaviour * > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_ScriptedBehaviour_Sm__Sg__Reverse__SWIG_1(std::vector< ScriptedBehaviour * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_ScriptedBehaviour_Sm__Sg__SetRange(std::vector< ScriptedBehaviour * > *self,int index,std::vector< ScriptedBehaviour * > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_ScriptedBehaviour_Sm__Sg__Contains(std::vector< ScriptedBehaviour * > *self,ScriptedBehaviour *const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_ScriptedBehaviour_Sm__Sg__IndexOf(std::vector< ScriptedBehaviour * > *self,ScriptedBehaviour *const &value){
        int index = -1;
        std::vector< ScriptedBehaviour * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_ScriptedBehaviour_Sm__Sg__LastIndexOf(std::vector< ScriptedBehaviour * > *self,ScriptedBehaviour *const &value){
        int index = -1;
        std::vector< ScriptedBehaviour * >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_ScriptedBehaviour_Sm__Sg__Remove(std::vector< ScriptedBehaviour * > *self,ScriptedBehaviour *const &value){
        std::vector< ScriptedBehaviour * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
          return true;
        }
        return false;
      }
SWIGINTERN std::vector< ModelRenderer * > *new_std_vector_Sl_ModelRenderer_Sm__Sg___SWIG_2(int capacity){
        std::vector< ModelRenderer * >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< ModelRenderer * >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN ModelRenderer *std_vector_Sl_ModelRenderer_Sm__Sg__getitemcopy(std::vector< ModelRenderer * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< ModelRenderer * >::value_type const &std_vector_Sl_ModelRenderer_Sm__Sg__getitem(std::vector< ModelRenderer * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_ModelRenderer_Sm__Sg__setitem(std::vector< ModelRenderer * > *self,int index,ModelRenderer *const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_ModelRenderer_Sm__Sg__AddRange(std::vector< ModelRenderer * > *self,std::vector< ModelRenderer * > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< ModelRenderer * > *std_vector_Sl_ModelRenderer_Sm__Sg__GetRange(std::vector< ModelRenderer * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< ModelRenderer * >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_ModelRenderer_Sm__Sg__Insert(std::vector< ModelRenderer * > *self,int index,ModelRenderer *const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_ModelRenderer_Sm__Sg__InsertRange(std::vector< ModelRenderer * > *self,int index,std::vector< ModelRenderer * > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_ModelRenderer_Sm__Sg__RemoveAt(std::vector< ModelRenderer * > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_ModelRenderer_Sm__Sg__RemoveRange(std::vector< ModelRenderer * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< ModelRenderer * > *std_vector_Sl_ModelRenderer_Sm__Sg__Repeat(ModelRenderer *const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< ModelRenderer * >(count, value);
      }
SWIGINTERN void std_vector_Sl_ModelRenderer_Sm__Sg__Reverse__SWIG_0(std::vector< ModelRenderer * > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_ModelRenderer_Sm__Sg__Reverse__SWIG_1(std::vector< ModelRenderer * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_ModelRenderer_Sm__Sg__SetRange(std::vector< ModelRenderer * > *self,int index,std::vector< ModelRenderer * > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_ModelRenderer_Sm__Sg__Contains(std::vector< ModelRenderer * > *self,ModelRenderer *const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_ModelRenderer_Sm__Sg__IndexOf(std::vector< ModelRenderer * > *self,ModelRenderer *const &value){
        int index = -1;
        std::vector< ModelRenderer * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_ModelRenderer_Sm__Sg__LastIndexOf(std::vector< ModelRenderer * > *self,ModelRenderer *const &value){
        int index = -1;
        std::vector< ModelRenderer * >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_ModelRenderer_Sm__Sg__Remove(std::vector< ModelRenderer * > *self,ModelRenderer *const &value){
        std::vector< ModelRenderer * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
          return true;
        }
        return false;
      }
SWIGINTERN std::vector< Entity * > *new_std_vector_Sl_Entity_Sm__Sg___SWIG_2(int capacity){
        std::vector< Entity * >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< Entity * >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN Entity *std_vector_Sl_Entity_Sm__Sg__getitemcopy(std::vector< Entity * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< Entity * >::value_type const &std_vector_Sl_Entity_Sm__Sg__getitem(std::vector< Entity * > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Entity_Sm__Sg__setitem(std::vector< Entity * > *self,int index,Entity *const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Entity_Sm__Sg__AddRange(std::vector< Entity * > *self,std::vector< Entity * > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< Entity * > *std_vector_Sl_Entity_Sm__Sg__GetRange(std::vector< Entity * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< Entity * >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Entity_Sm__Sg__Insert(std::vector< Entity * > *self,int index,Entity *const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Entity_Sm__Sg__InsertRange(std::vector< Entity * > *self,int index,std::vector< Entity * > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Entity_Sm__Sg__RemoveAt(std::vector< Entity * > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_Entity_Sm__Sg__RemoveRange(std::vector< Entity * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< Entity * > *std_vector_Sl_Entity_Sm__Sg__Repeat(Entity *const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< Entity * >(count, value);
      }
SWIGINTERN void std_vector_Sl_Entity_Sm__Sg__Reverse__SWIG_0(std::vector< Entity * > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_Entity_Sm__Sg__Reverse__SWIG_1(std::vector< Entity * > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_Entity_Sm__Sg__SetRange(std::vector< Entity * > *self,int index,std::vector< Entity * > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_Entity_Sm__Sg__Contains(std::vector< Entity * > *self,Entity *const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_Entity_Sm__Sg__IndexOf(std::vector< Entity * > *self,Entity *const &value){
        int index = -1;
        std::vector< Entity * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_Entity_Sm__Sg__LastIndexOf(std::vector< Entity * > *self,Entity *const &value){
        int index = -1;
        std::vector< Entity * >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_Entity_Sm__Sg__Remove(std::vector< Entity * > *self,Entity *const &value){
        std::vector< Entity * >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
          return true;
        }
        return false;
      }

	#include "physic_actor.hpp"

	using namespace PhysicSystem;


	#include "keycode.hpp"

	#include "singleton.hpp"
	#include "input_manager.hpp"


	#include "singleton.hpp"
	#include "scene_manager.hpp"


	#include "singleton.hpp"
	#include "time_manager.hpp"


	#include "debug.hpp"




/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "ccengine_wrap.h"

SwigDirector_Behaviour::SwigDirector_Behaviour() : Behaviour(), Swig::Director() {
  swig_init_callbacks();
}

SwigDirector_Behaviour::~SwigDirector_Behaviour() {
  
}


void SwigDirector_Behaviour::swig_connect_director() {
  
}

void SwigDirector_Behaviour::swig_init_callbacks() {
  
}


#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector2_x_set(void * jarg1, float jarg2) {
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector2_x_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  result = (float) ((arg1)->x);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector2_y_set(void * jarg1, float jarg2) {
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector2_y_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  result = (float) ((arg1)->y);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector2_data_set(void * jarg1, void * jarg2) {
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float *arg2 ;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (float *)jarg2; 
  {
    size_t ii;
    float *b = (float *) arg1->data;
    for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((float *) arg2 + ii);
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_data_get(void * jarg1) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float *result = 0 ;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  result = (float *)(float *) ((arg1)->data);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector2__SWIG_0() {
  void * jresult ;
  CCMaths::Vector2 *result = 0 ;
  
  result = (CCMaths::Vector2 *)new CCMaths::Vector2();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector2__SWIG_1(float jarg1) {
  void * jresult ;
  float arg1 ;
  CCMaths::Vector2 *result = 0 ;
  
  arg1 = (float)jarg1; 
  result = (CCMaths::Vector2 *)new CCMaths::Vector2(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector2__SWIG_2(float jarg1, float jarg2) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  CCMaths::Vector2 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  result = (CCMaths::Vector2 *)new CCMaths::Vector2(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_operator_add__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  CCMaths::Vector2 *arg2 = 0 ;
  CCMaths::Vector2 result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (CCMaths::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector2 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Vector2 const *)arg1)->operator +((CCMaths::Vector2 const &)*arg2);
  jresult = new CCMaths::Vector2((const CCMaths::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_operator_add__SWIG_1(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float arg2 ;
  CCMaths::Vector2 result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Vector2 const *)arg1)->operator +(arg2);
  jresult = new CCMaths::Vector2((const CCMaths::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_operator_substract__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  CCMaths::Vector2 result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  result = ((CCMaths::Vector2 const *)arg1)->operator -();
  jresult = new CCMaths::Vector2((const CCMaths::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_operator_substract__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  CCMaths::Vector2 *arg2 = 0 ;
  CCMaths::Vector2 result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (CCMaths::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector2 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Vector2 const *)arg1)->operator -((CCMaths::Vector2 const &)*arg2);
  jresult = new CCMaths::Vector2((const CCMaths::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_operator_substract__SWIG_2(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float arg2 ;
  CCMaths::Vector2 result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Vector2 const *)arg1)->operator -(arg2);
  jresult = new CCMaths::Vector2((const CCMaths::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector2_operator_multiply__SWIG_0(void * jarg1, void * jarg2) {
  float jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  CCMaths::Vector2 *arg2 = 0 ;
  float result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (CCMaths::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector2 const & type is null", 0);
    return 0;
  } 
  result = (float)((CCMaths::Vector2 const *)arg1)->operator *((CCMaths::Vector2 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_operator_multiply__SWIG_1(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float arg2 ;
  CCMaths::Vector2 result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Vector2 const *)arg1)->operator *(arg2);
  jresult = new CCMaths::Vector2((const CCMaths::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector2_Dot__SWIG_0(void * jarg1, void * jarg2) {
  float jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  CCMaths::Vector2 *arg2 = 0 ;
  float result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (CCMaths::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector2 const & type is null", 0);
    return 0;
  } 
  result = (float)((CCMaths::Vector2 const *)arg1)->Dot((CCMaths::Vector2 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector2_SquareLength(void * jarg1) {
  float jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  result = (float)((CCMaths::Vector2 const *)arg1)->SquareLength();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector2_Length(void * jarg1) {
  float jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  result = (float)((CCMaths::Vector2 const *)arg1)->Length();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_Normalize__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  CCMaths::Vector2 *result = 0 ;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  result = (CCMaths::Vector2 *) &(arg1)->Normalize();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_Normalize__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  CCMaths::Vector2 *arg2 = 0 ;
  CCMaths::Vector2 *result = 0 ;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  arg2 = (CCMaths::Vector2 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector2 & type is null", 0);
    return 0;
  } 
  result = (CCMaths::Vector2 *) &(arg1)->Normalize(*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_Normalized__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  CCMaths::Vector2 result;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  result = ((CCMaths::Vector2 const *)arg1)->Normalized();
  jresult = new CCMaths::Vector2((const CCMaths::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_XAxis_get() {
  void * jresult ;
  CCMaths::Vector2 *result = 0 ;
  
  result = (CCMaths::Vector2 *)&CCMaths::Vector2::XAxis;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_YAxis_get() {
  void * jresult ;
  CCMaths::Vector2 *result = 0 ;
  
  result = (CCMaths::Vector2 *)&CCMaths::Vector2::YAxis;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_Zero_get() {
  void * jresult ;
  CCMaths::Vector2 *result = 0 ;
  
  result = (CCMaths::Vector2 *)&CCMaths::Vector2::Zero;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector2_One_get() {
  void * jresult ;
  CCMaths::Vector2 *result = 0 ;
  
  result = (CCMaths::Vector2 *)&CCMaths::Vector2::One;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Vector2(void * jarg1) {
  CCMaths::Vector2 *arg1 = (CCMaths::Vector2 *) 0 ;
  
  arg1 = (CCMaths::Vector2 *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_x_set(void * jarg1, float jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_x_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float) ((arg1)->x);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_y_set(void * jarg1, float jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_y_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float) ((arg1)->y);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_z_set(void * jarg1, float jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->z = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_z_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float) ((arg1)->z);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_r_set(void * jarg1, float jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->r = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_r_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float) ((arg1)->r);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_g_set(void * jarg1, float jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->g = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_g_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float) ((arg1)->g);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_b_set(void * jarg1, float jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->b = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_b_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float) ((arg1)->b);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_pitch_set(void * jarg1, float jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->pitch = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_pitch_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float) ((arg1)->pitch);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_yaw_set(void * jarg1, float jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->yaw = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_yaw_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float) ((arg1)->yaw);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_roll_set(void * jarg1, float jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->roll = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_roll_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float) ((arg1)->roll);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_data_set(void * jarg1, void * jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float *arg2 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float *)jarg2; 
  {
    size_t ii;
    float *b = (float *) arg1->data;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((float *) arg2 + ii);
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_data_get(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float *result = 0 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float *)(float *) ((arg1)->data);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_xy_set(void * jarg1, void * jarg2) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector2 *arg2 = (CCMaths::Vector2 *) 0 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (CCMaths::Vector2 *)jarg2; 
  if (arg1) (arg1)->xy = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_xy_get(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector2 *result = 0 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (CCMaths::Vector2 *)& ((arg1)->xy);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector3__SWIG_0() {
  void * jresult ;
  CCMaths::Vector3 *result = 0 ;
  
  result = (CCMaths::Vector3 *)new CCMaths::Vector3();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector3__SWIG_1(float jarg1) {
  void * jresult ;
  float arg1 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (float)jarg1; 
  result = (CCMaths::Vector3 *)new CCMaths::Vector3(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector3__SWIG_2(float jarg1, float jarg2, float jarg3) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  result = (CCMaths::Vector3 *)new CCMaths::Vector3(arg1,arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector3__SWIG_3(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector2 *arg1 = 0 ;
  float arg2 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (CCMaths::Vector2 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector2 const & type is null", 0);
    return 0;
  } 
  arg2 = (float)jarg2; 
  result = (CCMaths::Vector3 *)new CCMaths::Vector3((CCMaths::Vector2 const &)*arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_operator_add__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Vector3 const *)arg1)->operator +((CCMaths::Vector3 const &)*arg2);
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_operator_add__SWIG_1(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Vector3 const *)arg1)->operator +(arg2);
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_operator_substract__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = ((CCMaths::Vector3 const *)arg1)->operator -();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_operator_substract__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Vector3 const *)arg1)->operator -((CCMaths::Vector3 const &)*arg2);
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_operator_substract__SWIG_2(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Vector3 const *)arg1)->operator -(arg2);
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_operator_multiply__SWIG_0(void * jarg1, void * jarg2) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (float)((CCMaths::Vector3 const *)arg1)->operator *((CCMaths::Vector3 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_operator_multiply__SWIG_1(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Vector3 const *)arg1)->operator *(arg2);
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_Dot__SWIG_0(void * jarg1, void * jarg2) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (float)((CCMaths::Vector3 const *)arg1)->Dot((CCMaths::Vector3 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_Multiply__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (CCMaths::Vector3 *) &(arg1)->Multiply((CCMaths::Vector3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_Cross__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Vector3 const *)arg1)->Cross((CCMaths::Vector3 const &)*arg2);
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_SquareLength(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float)((CCMaths::Vector3 const *)arg1)->SquareLength();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector3_Length(void * jarg1) {
  float jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (float)((CCMaths::Vector3 const *)arg1)->Length();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector3_ClampLength__SWIG_0(void * jarg1, float jarg2, float jarg3) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  float arg2 ;
  float arg3 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  (arg1)->ClampLength(arg2,arg3);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_Normalize__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = (CCMaths::Vector3 *) &(arg1)->Normalize();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_Normalized__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  result = ((CCMaths::Vector3 const *)arg1)->Normalized();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_XAxis_get() {
  void * jresult ;
  CCMaths::Vector3 *result = 0 ;
  
  result = (CCMaths::Vector3 *)&CCMaths::Vector3::XAxis;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_YAxis_get() {
  void * jresult ;
  CCMaths::Vector3 *result = 0 ;
  
  result = (CCMaths::Vector3 *)&CCMaths::Vector3::YAxis;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_ZAxis_get() {
  void * jresult ;
  CCMaths::Vector3 *result = 0 ;
  
  result = (CCMaths::Vector3 *)&CCMaths::Vector3::ZAxis;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_Forward_get() {
  void * jresult ;
  CCMaths::Vector3 *result = 0 ;
  
  result = (CCMaths::Vector3 *)&CCMaths::Vector3::Forward;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_Up_get() {
  void * jresult ;
  CCMaths::Vector3 *result = 0 ;
  
  result = (CCMaths::Vector3 *)&CCMaths::Vector3::Up;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_Right_get() {
  void * jresult ;
  CCMaths::Vector3 *result = 0 ;
  
  result = (CCMaths::Vector3 *)&CCMaths::Vector3::Right;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_Zero_get() {
  void * jresult ;
  CCMaths::Vector3 *result = 0 ;
  
  result = (CCMaths::Vector3 *)&CCMaths::Vector3::Zero;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector3_One_get() {
  void * jresult ;
  CCMaths::Vector3 *result = 0 ;
  
  result = (CCMaths::Vector3 *)&CCMaths::Vector3::One;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Vector3(void * jarg1) {
  CCMaths::Vector3 *arg1 = (CCMaths::Vector3 *) 0 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_x_set(void * jarg1, float jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_x_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float) ((arg1)->x);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_y_set(void * jarg1, float jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_y_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float) ((arg1)->y);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_z_set(void * jarg1, float jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->z = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_z_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float) ((arg1)->z);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_w_set(void * jarg1, float jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->w = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_w_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float) ((arg1)->w);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_r_set(void * jarg1, float jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->r = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_r_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float) ((arg1)->r);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_g_set(void * jarg1, float jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->g = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_g_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float) ((arg1)->g);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_b_set(void * jarg1, float jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->b = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_b_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float) ((arg1)->b);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_a_set(void * jarg1, float jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->a = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_a_get(void * jarg1) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float) ((arg1)->a);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_data_set(void * jarg1, void * jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float *arg2 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float *)jarg2; 
  {
    size_t ii;
    float *b = (float *) arg1->data;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_data_get(void * jarg1) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float *result = 0 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float *)(float *) ((arg1)->data);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_xyz_set(void * jarg1, void * jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->xyz = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_xyz_get(void * jarg1) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (CCMaths::Vector3 *)& ((arg1)->xyz);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Vector4_rgb_set(void * jarg1, void * jarg2) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->rgb = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_rgb_get(void * jarg1) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (CCMaths::Vector3 *)& ((arg1)->rgb);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector4__SWIG_0() {
  void * jresult ;
  CCMaths::Vector4 *result = 0 ;
  
  result = (CCMaths::Vector4 *)new CCMaths::Vector4();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector4__SWIG_1(float jarg1) {
  void * jresult ;
  float arg1 ;
  CCMaths::Vector4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  result = (CCMaths::Vector4 *)new CCMaths::Vector4(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector4__SWIG_2(float jarg1, float jarg2, float jarg3, float jarg4) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  CCMaths::Vector4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  result = (CCMaths::Vector4 *)new CCMaths::Vector4(arg1,arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Vector4__SWIG_3(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  float arg2 ;
  CCMaths::Vector4 *result = 0 ;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  arg2 = (float)jarg2; 
  result = (CCMaths::Vector4 *)new CCMaths::Vector4((CCMaths::Vector3 const &)*arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_operator_add__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector4 *arg2 = 0 ;
  CCMaths::Vector4 result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (CCMaths::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector4 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Vector4 const *)arg1)->operator +((CCMaths::Vector4 const &)*arg2);
  jresult = new CCMaths::Vector4((const CCMaths::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_operator_add__SWIG_1(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  CCMaths::Vector4 result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Vector4 const *)arg1)->operator +(arg2);
  jresult = new CCMaths::Vector4((const CCMaths::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_operator_substract__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector4 result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = ((CCMaths::Vector4 const *)arg1)->operator -();
  jresult = new CCMaths::Vector4((const CCMaths::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_operator_substract__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector4 *arg2 = 0 ;
  CCMaths::Vector4 result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (CCMaths::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector4 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Vector4 const *)arg1)->operator -((CCMaths::Vector4 const &)*arg2);
  jresult = new CCMaths::Vector4((const CCMaths::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_operator_substract__SWIG_2(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  CCMaths::Vector4 result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Vector4 const *)arg1)->operator -(arg2);
  jresult = new CCMaths::Vector4((const CCMaths::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_operator_multiply__SWIG_0(void * jarg1, void * jarg2) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector4 *arg2 = 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (CCMaths::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector4 const & type is null", 0);
    return 0;
  } 
  result = (float)((CCMaths::Vector4 const *)arg1)->operator *((CCMaths::Vector4 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_operator_multiply__SWIG_1(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float arg2 ;
  CCMaths::Vector4 result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Vector4 const *)arg1)->operator *(arg2);
  jresult = new CCMaths::Vector4((const CCMaths::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_Dot__SWIG_0(void * jarg1, void * jarg2) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector4 *arg2 = 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  arg2 = (CCMaths::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector4 const & type is null", 0);
    return 0;
  } 
  result = (float)((CCMaths::Vector4 const *)arg1)->Dot((CCMaths::Vector4 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_SquareLength(void * jarg1) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float)((CCMaths::Vector4 const *)arg1)->SquareLength();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Vector4_Length(void * jarg1) {
  float jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (float)((CCMaths::Vector4 const *)arg1)->Length();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_Normalize__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector4 *result = 0 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = (CCMaths::Vector4 *) &(arg1)->Normalize();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_Normalized__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  CCMaths::Vector4 result;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  result = ((CCMaths::Vector4 const *)arg1)->Normalized();
  jresult = new CCMaths::Vector4((const CCMaths::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_XAxis_get() {
  void * jresult ;
  CCMaths::Vector4 *result = 0 ;
  
  result = (CCMaths::Vector4 *)&CCMaths::Vector4::XAxis;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_YAxis_get() {
  void * jresult ;
  CCMaths::Vector4 *result = 0 ;
  
  result = (CCMaths::Vector4 *)&CCMaths::Vector4::YAxis;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_ZAxis_get() {
  void * jresult ;
  CCMaths::Vector4 *result = 0 ;
  
  result = (CCMaths::Vector4 *)&CCMaths::Vector4::ZAxis;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_WAxis_get() {
  void * jresult ;
  CCMaths::Vector4 *result = 0 ;
  
  result = (CCMaths::Vector4 *)&CCMaths::Vector4::WAxis;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_Zero_get() {
  void * jresult ;
  CCMaths::Vector4 *result = 0 ;
  
  result = (CCMaths::Vector4 *)&CCMaths::Vector4::Zero;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Vector4_One_get() {
  void * jresult ;
  CCMaths::Vector4 *result = 0 ;
  
  result = (CCMaths::Vector4 *)&CCMaths::Vector4::One;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Vector4(void * jarg1) {
  CCMaths::Vector4 *arg1 = (CCMaths::Vector4 *) 0 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_0(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7, float jarg8, float jarg9, float jarg10, float jarg11, float jarg12, float jarg13, float jarg14, float jarg15, float jarg16) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  float arg10 ;
  float arg11 ;
  float arg12 ;
  float arg13 ;
  float arg14 ;
  float arg15 ;
  float arg16 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  arg8 = (float)jarg8; 
  arg9 = (float)jarg9; 
  arg10 = (float)jarg10; 
  arg11 = (float)jarg11; 
  arg12 = (float)jarg12; 
  arg13 = (float)jarg13; 
  arg14 = (float)jarg14; 
  arg15 = (float)jarg15; 
  arg16 = (float)jarg16; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_1(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7, float jarg8, float jarg9, float jarg10, float jarg11, float jarg12, float jarg13, float jarg14, float jarg15) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  float arg10 ;
  float arg11 ;
  float arg12 ;
  float arg13 ;
  float arg14 ;
  float arg15 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  arg8 = (float)jarg8; 
  arg9 = (float)jarg9; 
  arg10 = (float)jarg10; 
  arg11 = (float)jarg11; 
  arg12 = (float)jarg12; 
  arg13 = (float)jarg13; 
  arg14 = (float)jarg14; 
  arg15 = (float)jarg15; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_2(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7, float jarg8, float jarg9, float jarg10, float jarg11, float jarg12, float jarg13, float jarg14) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  float arg10 ;
  float arg11 ;
  float arg12 ;
  float arg13 ;
  float arg14 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  arg8 = (float)jarg8; 
  arg9 = (float)jarg9; 
  arg10 = (float)jarg10; 
  arg11 = (float)jarg11; 
  arg12 = (float)jarg12; 
  arg13 = (float)jarg13; 
  arg14 = (float)jarg14; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_3(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7, float jarg8, float jarg9, float jarg10, float jarg11, float jarg12, float jarg13) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  float arg10 ;
  float arg11 ;
  float arg12 ;
  float arg13 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  arg8 = (float)jarg8; 
  arg9 = (float)jarg9; 
  arg10 = (float)jarg10; 
  arg11 = (float)jarg11; 
  arg12 = (float)jarg12; 
  arg13 = (float)jarg13; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_4(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7, float jarg8, float jarg9, float jarg10, float jarg11, float jarg12) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  float arg10 ;
  float arg11 ;
  float arg12 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  arg8 = (float)jarg8; 
  arg9 = (float)jarg9; 
  arg10 = (float)jarg10; 
  arg11 = (float)jarg11; 
  arg12 = (float)jarg12; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_5(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7, float jarg8, float jarg9, float jarg10, float jarg11) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  float arg10 ;
  float arg11 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  arg8 = (float)jarg8; 
  arg9 = (float)jarg9; 
  arg10 = (float)jarg10; 
  arg11 = (float)jarg11; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_6(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7, float jarg8, float jarg9, float jarg10) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  float arg10 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  arg8 = (float)jarg8; 
  arg9 = (float)jarg9; 
  arg10 = (float)jarg10; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_7(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7, float jarg8, float jarg9) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  arg8 = (float)jarg8; 
  arg9 = (float)jarg9; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_8(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7, float jarg8) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  arg8 = (float)jarg8; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_9(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  arg7 = (float)jarg7; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_10(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5,arg6);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_11(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4,arg5);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_12(float jarg1, float jarg2, float jarg3, float jarg4) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_13(float jarg1, float jarg2, float jarg3) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_14(float jarg1, float jarg2) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_15(float jarg1) {
  void * jresult ;
  float arg1 ;
  CCMaths::Matrix4 *result = 0 ;
  
  arg1 = (float)jarg1; 
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Matrix4__SWIG_16() {
  void * jresult ;
  CCMaths::Matrix4 *result = 0 ;
  
  result = (CCMaths::Matrix4 *)new CCMaths::Matrix4();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_data_set(void * jarg1, void * jarg2) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float *arg2 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (float *)jarg2; 
  {
    size_t ii;
    float *b = (float *) arg1->data;
    for (ii = 0; ii < (size_t)16; ii++) b[ii] = *((float *) arg2 + ii);
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_data_get(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float *result = 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = (float *)(float *) ((arg1)->data);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_row_set(void * jarg1, void * jarg2) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector4 *arg2 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (CCMaths::Vector4 *)jarg2; 
  {
    size_t ii;
    CCMaths::Vector4 *b = (CCMaths::Vector4 *) arg1->row;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((CCMaths::Vector4 *) arg2 + ii);
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_row_get(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector4 *result = 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = (CCMaths::Vector4 *)(CCMaths::Vector4 *) ((arg1)->row);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_right_set(void * jarg1, void * jarg2) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->right = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_right_get(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = (CCMaths::Vector3 *)& ((arg1)->right);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_m4_set(void * jarg1, float jarg2) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->m4 = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Matrix4_m4_get(void * jarg1) {
  float jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = (float) ((arg1)->m4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_up_set(void * jarg1, void * jarg2) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->up = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_up_get(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = (CCMaths::Vector3 *)& ((arg1)->up);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_m8_set(void * jarg1, float jarg2) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->m8 = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Matrix4_m8_get(void * jarg1) {
  float jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = (float) ((arg1)->m8);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_back_set(void * jarg1, void * jarg2) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->back = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_back_get(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = (CCMaths::Vector3 *)& ((arg1)->back);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_m12_set(void * jarg1, float jarg2) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->m12 = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Matrix4_m12_get(void * jarg1) {
  float jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = (float) ((arg1)->m12);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_position_set(void * jarg1, void * jarg2) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->position = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_position_get(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = (CCMaths::Vector3 *)& ((arg1)->position);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_uniformScale_set(void * jarg1, float jarg2) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->uniformScale = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Matrix4_uniformScale_get(void * jarg1) {
  float jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = (float) ((arg1)->uniformScale);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_Identity_get() {
  void * jresult ;
  CCMaths::Matrix4 *result = 0 ;
  
  result = (CCMaths::Matrix4 *)&CCMaths::Matrix4::Identity;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_operator_multiply__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector4 *arg2 = 0 ;
  CCMaths::Vector4 result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (CCMaths::Vector4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector4 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Matrix4 const *)arg1)->operator *((CCMaths::Vector4 const &)*arg2);
  jresult = new CCMaths::Vector4((const CCMaths::Vector4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_operator_multiply__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Matrix4 *arg2 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (CCMaths::Matrix4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Matrix4 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Matrix4 const *)arg1)->operator *((CCMaths::Matrix4 const &)*arg2);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_operator_multiply__SWIG_2(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  float arg2 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Matrix4 const *)arg1)->operator *(arg2);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_Transpose__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = ((CCMaths::Matrix4 const *)arg1)->Transpose();
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_Inverse__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = ((CCMaths::Matrix4 const *)arg1)->Inverse();
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_Translate(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::Translate((CCMaths::Vector3 const &)*arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_Scale__SWIG_0(float jarg1) {
  void * jresult ;
  float arg1 ;
  CCMaths::Matrix4 result;
  
  arg1 = (float)jarg1; 
  result = CCMaths::Matrix4::Scale(arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_Scale__SWIG_1(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::Scale((CCMaths::Vector3 const &)*arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_NormalizeScale(void * jarg1) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  (arg1)->NormalizeScale();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_NormalizedScale(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = ((CCMaths::Matrix4 const *)arg1)->NormalizedScale();
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateXYZ(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::RotateXYZ((CCMaths::Vector3 const &)*arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateZYX(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::RotateZYX((CCMaths::Vector3 const &)*arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateZXY(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::RotateZXY((CCMaths::Vector3 const &)*arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateYXZ(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::RotateYXZ((CCMaths::Vector3 const &)*arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateXZY(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::RotateXZY((CCMaths::Vector3 const &)*arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateYZX(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::RotateYZX((CCMaths::Vector3 const &)*arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateX__SWIG_0(float jarg1) {
  void * jresult ;
  float arg1 ;
  CCMaths::Matrix4 result;
  
  arg1 = (float)jarg1; 
  result = CCMaths::Matrix4::RotateX(arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateY__SWIG_0(float jarg1) {
  void * jresult ;
  float arg1 ;
  CCMaths::Matrix4 result;
  
  arg1 = (float)jarg1; 
  result = CCMaths::Matrix4::RotateY(arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateZ__SWIG_0(float jarg1) {
  void * jresult ;
  float arg1 ;
  CCMaths::Matrix4 result;
  
  arg1 = (float)jarg1; 
  result = CCMaths::Matrix4::RotateZ(arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateX__SWIG_1(float jarg1, float jarg2) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  CCMaths::Matrix4 result;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  result = CCMaths::Matrix4::RotateX(arg1,arg2);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateY__SWIG_1(float jarg1, float jarg2) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  CCMaths::Matrix4 result;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  result = CCMaths::Matrix4::RotateY(arg1,arg2);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_RotateZ__SWIG_1(float jarg1, float jarg2) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  CCMaths::Matrix4 result;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  result = CCMaths::Matrix4::RotateZ(arg1,arg2);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Matrix4_Decompose(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  CCMaths::Matrix4 *arg1 = 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Vector3 *arg3 = 0 ;
  CCMaths::Vector3 *arg4 = 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Matrix4 const & type is null", 0);
    return ;
  } 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 & type is null", 0);
    return ;
  } 
  arg3 = (CCMaths::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 & type is null", 0);
    return ;
  } 
  arg4 = (CCMaths::Vector3 *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 & type is null", 0);
    return ;
  } 
  CCMaths::Matrix4::Decompose((CCMaths::Matrix4 const &)*arg1,*arg2,*arg3,*arg4);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_GetRotationMatrix__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = ((CCMaths::Matrix4 const *)arg1)->GetRotationMatrix();
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_GetTranslationMatrix__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = ((CCMaths::Matrix4 const *)arg1)->GetTranslationMatrix();
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_GetScaleMatrix__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = ((CCMaths::Matrix4 const *)arg1)->GetScaleMatrix();
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_GetScaleInMatrix__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  result = ((CCMaths::Matrix4 const *)arg1)->GetScaleInMatrix();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_Frustum(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  CCMaths::Matrix4 result;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  result = CCMaths::Matrix4::Frustum(arg1,arg2,arg3,arg4,arg5,arg6);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_Perspective(float jarg1, float jarg2, float jarg3, float jarg4) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  CCMaths::Matrix4 result;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  result = CCMaths::Matrix4::Perspective(arg1,arg2,arg3,arg4);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_Orthographic(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  CCMaths::Matrix4 result;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  arg6 = (float)jarg6; 
  result = CCMaths::Matrix4::Orthographic(arg1,arg2,arg3,arg4,arg5,arg6);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_ObliqueProjection(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = 0 ;
  CCMaths::Matrix4 *arg2 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector4 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector4 const & type is null", 0);
    return 0;
  } 
  arg2 = (CCMaths::Matrix4 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Matrix4 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::ObliqueProjection((CCMaths::Vector4 const &)*arg1,(CCMaths::Matrix4 const &)*arg2);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_LookAt__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Vector3 *arg3 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (CCMaths::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::LookAt((CCMaths::Vector3 const &)*arg1,(CCMaths::Vector3 const &)*arg2,(CCMaths::Vector3 const &)*arg3);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_LookAt__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::LookAt((CCMaths::Vector3 const &)*arg1,(CCMaths::Vector3 const &)*arg2);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Matrix4_LookAt__SWIG_2(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Matrix4::LookAt((CCMaths::Vector3 const &)*arg1);
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Matrix4(void * jarg1) {
  CCMaths::Matrix4 *arg1 = (CCMaths::Matrix4 *) 0 ;
  
  arg1 = (CCMaths::Matrix4 *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Quaternion_x_set(void * jarg1, float jarg2) {
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Quaternion_x_get(void * jarg1) {
  float jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = (float) ((arg1)->x);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Quaternion_y_set(void * jarg1, float jarg2) {
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Quaternion_y_get(void * jarg1) {
  float jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = (float) ((arg1)->y);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Quaternion_z_set(void * jarg1, float jarg2) {
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->z = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Quaternion_z_get(void * jarg1) {
  float jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = (float) ((arg1)->z);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Quaternion_w_set(void * jarg1, float jarg2) {
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float arg2 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->w = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Quaternion_w_get(void * jarg1) {
  float jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = (float) ((arg1)->w);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Quaternion_data_set(void * jarg1, void * jarg2) {
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float *arg2 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (float *)jarg2; 
  {
    size_t ii;
    float *b = (float *) arg1->data;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_data_get(void * jarg1) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float *result = 0 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = (float *)(float *) ((arg1)->data);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Quaternion_xyz_set(void * jarg1, void * jarg2) {
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->xyz = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_xyz_get(void * jarg1) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = (CCMaths::Vector3 *)& ((arg1)->xyz);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_Identity_get() {
  void * jresult ;
  CCMaths::Quaternion *result = 0 ;
  
  result = (CCMaths::Quaternion *)&CCMaths::Quaternion::Identity;
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Quaternion__SWIG_0() {
  void * jresult ;
  CCMaths::Quaternion *result = 0 ;
  
  result = (CCMaths::Quaternion *)new CCMaths::Quaternion();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Quaternion__SWIG_1(float jarg1, float jarg2, float jarg3, float jarg4) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  CCMaths::Quaternion *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  result = (CCMaths::Quaternion *)new CCMaths::Quaternion(arg1,arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Quaternion__SWIG_2(float jarg1, void * jarg2) {
  void * jresult ;
  float arg1 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Quaternion *result = 0 ;
  
  arg1 = (float)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = (CCMaths::Quaternion *)new CCMaths::Quaternion(arg1,(CCMaths::Vector3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Quaternion__SWIG_3(void * jarg1) {
  void * jresult ;
  CCMaths::Vector4 *arg1 = 0 ;
  CCMaths::Quaternion *result = 0 ;
  
  arg1 = (CCMaths::Vector4 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector4 const & type is null", 0);
    return 0;
  } 
  result = (CCMaths::Quaternion *)new CCMaths::Quaternion((CCMaths::Vector4 const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_operator_add(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Quaternion *arg2 = 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (CCMaths::Quaternion *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Quaternion const *)arg1)->operator +((CCMaths::Quaternion const &)*arg2);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_operator_substract__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = ((CCMaths::Quaternion const *)arg1)->operator -();
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_operator_substract__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Quaternion *arg2 = 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (CCMaths::Quaternion *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Quaternion const *)arg1)->operator -((CCMaths::Quaternion const &)*arg2);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_operator_multiply__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Quaternion *arg2 = 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (CCMaths::Quaternion *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Quaternion const *)arg1)->operator *((CCMaths::Quaternion const &)*arg2);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_operator_multiply__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Quaternion const *)arg1)->operator *((CCMaths::Vector3 const &)*arg2);
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_operator_multiply__SWIG_2(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float arg2 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Quaternion const *)arg1)->operator *(arg2);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_operator_divide__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Quaternion *arg2 = 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (CCMaths::Quaternion *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Quaternion const *)arg1)->operator /((CCMaths::Quaternion const &)*arg2);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_operator_divide__SWIG_1(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float arg2 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (float)jarg2; 
  result = ((CCMaths::Quaternion const *)arg1)->operator /(arg2);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Quaternion_Dot__SWIG_0(void * jarg1, void * jarg2) {
  float jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Quaternion *arg2 = 0 ;
  float result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (CCMaths::Quaternion *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  result = (float)((CCMaths::Quaternion const *)arg1)->Dot((CCMaths::Quaternion const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Quaternion_SquareNorm(void * jarg1) {
  float jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = (float)((CCMaths::Quaternion const *)arg1)->SquareNorm();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Quaternion_Norm(void * jarg1) {
  float jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  float result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = (float)((CCMaths::Quaternion const *)arg1)->Norm();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_Normalize__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Quaternion *result = 0 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = (CCMaths::Quaternion *) &(arg1)->Normalize();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_Normalized__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = ((CCMaths::Quaternion const *)arg1)->Normalized();
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_Conjugate__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = ((CCMaths::Quaternion const *)arg1)->Conjugate();
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_Invert__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = ((CCMaths::Quaternion const *)arg1)->Invert();
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_ToEuler__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = ((CCMaths::Quaternion const *)arg1)->ToEuler();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_ToMatrix__SWIG_0(void * jarg1) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Matrix4 result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  result = ((CCMaths::Quaternion const *)arg1)->ToMatrix();
  jresult = new CCMaths::Matrix4((const CCMaths::Matrix4 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Quaternion_ToAxisAngle__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  float *arg3 = 0 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 & type is null", 0);
    return ;
  } 
  arg3 = (float *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "float & type is null", 0);
    return ;
  } 
  ((CCMaths::Quaternion const *)arg1)->ToAxisAngle(*arg2,*arg3);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_FromEuler__SWIG_0(float jarg1, float jarg2, float jarg3) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  CCMaths::Quaternion result;
  
  arg1 = (float)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  result = CCMaths::Quaternion::FromEuler(arg1,arg2,arg3);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_FromEuler__SWIG_1(void * jarg1) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Quaternion::FromEuler((CCMaths::Vector3 const &)*arg1);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_FromAxisAngle(void * jarg1, float jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  float arg2 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  arg2 = (float)jarg2; 
  result = CCMaths::Quaternion::FromAxisAngle((CCMaths::Vector3 const &)*arg1,arg2);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_FromMatrix(void * jarg1) {
  void * jresult ;
  CCMaths::Matrix4 *arg1 = 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Matrix4 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Matrix4 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Quaternion::FromMatrix((CCMaths::Matrix4 const &)*arg1);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_FromToRotation(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Vector3 *arg1 = 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Vector3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = CCMaths::Quaternion::FromToRotation((CCMaths::Vector3 const &)*arg1,(CCMaths::Vector3 const &)*arg2);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_RotateVector3__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  result = ((CCMaths::Quaternion const *)arg1)->RotateVector3((CCMaths::Vector3 const &)*arg2);
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_Lerp(void * jarg1, void * jarg2, float jarg3) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = 0 ;
  CCMaths::Quaternion *arg2 = 0 ;
  float arg3 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  arg2 = (CCMaths::Quaternion *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  arg3 = (float)jarg3; 
  result = CCMaths::Quaternion::Lerp((CCMaths::Quaternion const &)*arg1,(CCMaths::Quaternion const &)*arg2,arg3);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_NLerp(void * jarg1, void * jarg2, float jarg3) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = 0 ;
  CCMaths::Quaternion *arg2 = 0 ;
  float arg3 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  arg2 = (CCMaths::Quaternion *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  arg3 = (float)jarg3; 
  result = CCMaths::Quaternion::NLerp((CCMaths::Quaternion const &)*arg1,(CCMaths::Quaternion const &)*arg2,arg3);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Quaternion_SLerp(void * jarg1, void * jarg2, float jarg3) {
  void * jresult ;
  CCMaths::Quaternion *arg1 = 0 ;
  CCMaths::Quaternion *arg2 = 0 ;
  float arg3 ;
  CCMaths::Quaternion result;
  
  arg1 = (CCMaths::Quaternion *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  arg2 = (CCMaths::Quaternion *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return 0;
  } 
  arg3 = (float)jarg3; 
  result = CCMaths::Quaternion::SLerp((CCMaths::Quaternion const &)*arg1,(CCMaths::Quaternion const &)*arg2,arg3);
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Quaternion(void * jarg1) {
  CCMaths::Quaternion *arg1 = (CCMaths::Quaternion *) 0 ;
  
  arg1 = (CCMaths::Quaternion *)jarg1; 
  delete arg1;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_TAU_get() {
  float jresult ;
  float result;
  
  result = (float)CCMaths::TAU;
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_PI_get() {
  float jresult ;
  float result;
  
  result = (float)CCMaths::PI;
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_DEG2RAD_get() {
  float jresult ;
  float result;
  
  result = (float)CCMaths::DEG2RAD;
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_RAD2DEG_get() {
  float jresult ;
  float result;
  
  result = (float)CCMaths::RAD2DEG;
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_ToRadians(float jarg1) {
  float jresult ;
  float arg1 ;
  float result;
  
  arg1 = (float)jarg1; 
  result = (float)CCMaths::ToRadians(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_ToDegrees(float jarg1) {
  float jresult ;
  float arg1 ;
  float result;
  
  arg1 = (float)jarg1; 
  result = (float)CCMaths::ToDegrees(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Cos(float jarg1) {
  float jresult ;
  float arg1 ;
  float result;
  
  arg1 = (float)jarg1; 
  result = (float)CCMaths::Cos(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Sin(float jarg1) {
  float jresult ;
  float arg1 ;
  float result;
  
  arg1 = (float)jarg1; 
  result = (float)CCMaths::Sin(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Tan(float jarg1) {
  float jresult ;
  float arg1 ;
  float result;
  
  arg1 = (float)jarg1; 
  result = (float)CCMaths::Tan(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Atan(float jarg1) {
  float jresult ;
  float arg1 ;
  float result;
  
  arg1 = (float)jarg1; 
  result = (float)CCMaths::Atan(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Abs(float jarg1) {
  float jresult ;
  float arg1 ;
  float result;
  
  arg1 = (float)jarg1; 
  result = (float)CCMaths::Abs(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Sqrt(float jarg1) {
  float jresult ;
  float arg1 ;
  float result;
  
  arg1 = (float)jarg1; 
  result = (float)CCMaths::Sqrt(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_BoolPattern__SWIG_0(int jarg1, unsigned int jarg2) {
  unsigned int jresult ;
  int arg1 ;
  unsigned int arg2 ;
  bool result;
  
  arg1 = (int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (bool)CCMaths::BoolPattern(arg1,arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_BoolPattern__SWIG_1(int jarg1) {
  unsigned int jresult ;
  int arg1 ;
  bool result;
  
  arg1 = (int)jarg1; 
  result = (bool)CCMaths::BoolPattern(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_BoolSign(unsigned int jarg1) {
  int jresult ;
  bool arg1 ;
  int result;
  
  arg1 = jarg1 ? true : false; 
  result = (int)CCMaths::BoolSign(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Round(double jarg1) {
  float jresult ;
  double *arg1 = 0 ;
  double temp1 ;
  float result;
  
  temp1 = (double)jarg1; 
  arg1 = &temp1; 
  result = (float)CCMaths::Round((double const &)*arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Object() {
  void * jresult ;
  Object *result = 0 ;
  
  result = (Object *)new Object();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Object(void * jarg1) {
  Object *arg1 = (Object *) 0 ;
  
  arg1 = (Object *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Behaviour(void * jarg1) {
  Behaviour *arg1 = (Behaviour *) 0 ;
  
  arg1 = (Behaviour *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Behaviour_GetHost(void * jarg1) {
  void * jresult ;
  Behaviour *arg1 = (Behaviour *) 0 ;
  Entity *result = 0 ;
  
  arg1 = (Behaviour *)jarg1; 
  result = (Entity *) &(arg1)->GetHost();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Behaviour() {
  void * jresult ;
  Behaviour *result = 0 ;
  
  result = (Behaviour *)new SwigDirector_Behaviour();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Behaviour_director_connect(void *objarg) {
  Behaviour *obj = (Behaviour *)objarg;
  SwigDirector_Behaviour *director = static_cast<SwigDirector_Behaviour *>(obj);
  director->swig_connect_director();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetPosition(void * jarg1, void * jarg2) {
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 & type is null", 0);
    return ;
  } 
  (arg1)->SetPosition(*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetGlobalPosition(void * jarg1, void * jarg2) {
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 & type is null", 0);
    return ;
  } 
  (arg1)->SetGlobalPosition(*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_GetPosition(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (Transform *)jarg1; 
  result = (arg1)->GetPosition();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_GetGlobalPosition(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (Transform *)jarg1; 
  result = (arg1)->GetGlobalPosition();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetRotation__SWIG_0(void * jarg1, void * jarg2) {
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->SetRotation((CCMaths::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetRotation__SWIG_1(void * jarg1, void * jarg2) {
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Quaternion *arg2 = 0 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (CCMaths::Quaternion *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return ;
  } 
  (arg1)->SetRotation((CCMaths::Quaternion const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetGlobalRotation__SWIG_0(void * jarg1, void * jarg2) {
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return ;
  } 
  (arg1)->SetGlobalRotation((CCMaths::Vector3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetGlobalRotation__SWIG_1(void * jarg1, void * jarg2) {
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Quaternion *arg2 = 0 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (CCMaths::Quaternion *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Quaternion const & type is null", 0);
    return ;
  } 
  (arg1)->SetGlobalRotation((CCMaths::Quaternion const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_GetEuler(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (Transform *)jarg1; 
  result = (arg1)->GetEuler();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_GetRotation(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (Transform *)jarg1; 
  result = (arg1)->GetRotation();
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_GetGlobalRotation(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Quaternion result;
  
  arg1 = (Transform *)jarg1; 
  result = (arg1)->GetGlobalRotation();
  jresult = new CCMaths::Quaternion((const CCMaths::Quaternion &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetScale(void * jarg1, void * jarg2) {
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 & type is null", 0);
    return ;
  } 
  (arg1)->SetScale(*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetGlobalScale(void * jarg1, void * jarg2) {
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 & type is null", 0);
    return ;
  } 
  (arg1)->SetGlobalScale(*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_GetScale(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (Transform *)jarg1; 
  result = (arg1)->GetScale();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_GetGlobalScale(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (Transform *)jarg1; 
  result = (arg1)->GetGlobalScale();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_Up(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (Transform *)jarg1; 
  result = (arg1)->Up();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_Right(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (Transform *)jarg1; 
  result = (arg1)->Right();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_Forward(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  CCMaths::Vector3 result;
  
  arg1 = (Transform *)jarg1; 
  result = (arg1)->Forward();
  jresult = new CCMaths::Vector3((const CCMaths::Vector3 &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_Transform_IsRoot(void * jarg1) {
  unsigned int jresult ;
  Transform *arg1 = (Transform *) 0 ;
  bool result;
  
  arg1 = (Transform *)jarg1; 
  result = (bool)(arg1)->IsRoot();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetParent__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3, unsigned int jarg4, unsigned int jarg5) {
  Transform *arg1 = (Transform *) 0 ;
  Transform *arg2 = (Transform *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (Transform *)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = jarg4 ? true : false; 
  arg5 = jarg5 ? true : false; 
  (arg1)->SetParent(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetParent__SWIG_1(void * jarg1, void * jarg2, unsigned int jarg3, unsigned int jarg4) {
  Transform *arg1 = (Transform *) 0 ;
  Transform *arg2 = (Transform *) 0 ;
  bool arg3 ;
  bool arg4 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (Transform *)jarg2; 
  arg3 = jarg3 ? true : false; 
  arg4 = jarg4 ? true : false; 
  (arg1)->SetParent(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetParent__SWIG_2(void * jarg1, void * jarg2, unsigned int jarg3) {
  Transform *arg1 = (Transform *) 0 ;
  Transform *arg2 = (Transform *) 0 ;
  bool arg3 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (Transform *)jarg2; 
  arg3 = jarg3 ? true : false; 
  (arg1)->SetParent(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Transform_SetParent__SWIG_3(void * jarg1, void * jarg2) {
  Transform *arg1 = (Transform *) 0 ;
  Transform *arg2 = (Transform *) 0 ;
  
  arg1 = (Transform *)jarg1; 
  arg2 = (Transform *)jarg2; 
  (arg1)->SetParent(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_GetParent(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  Transform *result = 0 ;
  
  arg1 = (Transform *)jarg1; 
  result = (Transform *)(arg1)->GetParent();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Transform_GetRootParent(void * jarg1) {
  void * jresult ;
  Transform *arg1 = (Transform *) 0 ;
  Transform *result = 0 ;
  
  arg1 = (Transform *)jarg1; 
  result = (Transform *)(arg1)->GetRootParent();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Transform(void * jarg1) {
  Transform *arg1 = (Transform *) 0 ;
  
  arg1 = (Transform *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_CameraComponent() {
  void * jresult ;
  CameraComponent *result = 0 ;
  
  result = (CameraComponent *)new CameraComponent();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponent_m_transform_set(void * jarg1, void * jarg2) {
  CameraComponent *arg1 = (CameraComponent *) 0 ;
  Transform *arg2 = (Transform *) 0 ;
  
  arg1 = (CameraComponent *)jarg1; 
  arg2 = (Transform *)jarg2; 
  if (arg1) (arg1)->m_transform = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_CameraComponent_m_transform_get(void * jarg1) {
  void * jresult ;
  CameraComponent *arg1 = (CameraComponent *) 0 ;
  Transform *result = 0 ;
  
  arg1 = (CameraComponent *)jarg1; 
  result = (Transform *) ((arg1)->m_transform);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_CameraComponent(void * jarg1) {
  CameraComponent *arg1 = (CameraComponent *) 0 ;
  
  arg1 = (CameraComponent *)jarg1; 
  delete arg1;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviour_GetScriptPath(void * jarg1) {
  char * jresult ;
  ScriptedBehaviour *arg1 = (ScriptedBehaviour *) 0 ;
  std::string result;
  
  arg1 = (ScriptedBehaviour *)jarg1; 
  result = (arg1)->GetScriptPath();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviour_SetScriptClass(void * jarg1, char * jarg2) {
  ScriptedBehaviour *arg1 = (ScriptedBehaviour *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (ScriptedBehaviour *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  (arg1)->SetScriptClass((std::string const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_ScriptedBehaviour(void * jarg1) {
  ScriptedBehaviour *arg1 = (ScriptedBehaviour *) 0 ;
  
  arg1 = (ScriptedBehaviour *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Mesh_CreateCylinder(void * jarg1, float jarg2, float jarg3, float jarg4) {
  std::shared_ptr< Mesh > arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  if (jarg1) arg1 = *(std::shared_ptr< Mesh > *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  Mesh::CreateCylinder(arg1,arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Mesh_CreateSphere(void * jarg1, float jarg2, float jarg3, float jarg4) {
  std::shared_ptr< Mesh > arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  if (jarg1) arg1 = *(std::shared_ptr< Mesh > *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  Mesh::CreateSphere(arg1,arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Mesh_CreateCube(void * jarg1, float jarg2, float jarg3, float jarg4) {
  std::shared_ptr< Mesh > arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  if (jarg1) arg1 = *(std::shared_ptr< Mesh > *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  Mesh::CreateCube(arg1,arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Mesh_CreateQuad(void * jarg1, float jarg2, float jarg3) {
  std::shared_ptr< Mesh > arg1 ;
  float arg2 ;
  float arg3 ;
  
  if (jarg1) arg1 = *(std::shared_ptr< Mesh > *)jarg1; 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  Mesh::CreateQuad(arg1,arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Mesh(void * jarg1) {
  Mesh *arg1 = (Mesh *) 0 ;
  std::shared_ptr< Mesh > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Mesh > *)jarg1;
  arg1 = (Mesh *)(smartarg1 ? smartarg1->get() : 0); 
  (void)arg1; delete smartarg1;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_Texture_GetWidth(void * jarg1) {
  int jresult ;
  Texture *arg1 = (Texture *) 0 ;
  std::shared_ptr< Texture > *smartarg1 = 0 ;
  int result;
  
  
  smartarg1 = (std::shared_ptr<  Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  result = (int)(arg1)->GetWidth();
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_Texture_GetHeight(void * jarg1) {
  int jresult ;
  Texture *arg1 = (Texture *) 0 ;
  std::shared_ptr< Texture > *smartarg1 = 0 ;
  int result;
  
  
  smartarg1 = (std::shared_ptr<  Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  result = (int)(arg1)->GetHeight();
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_Texture_GetSize(void * jarg1) {
  int jresult ;
  Texture *arg1 = (Texture *) 0 ;
  std::shared_ptr< Texture > *smartarg1 = 0 ;
  int result;
  
  
  smartarg1 = (std::shared_ptr<  Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  result = (int)(arg1)->GetSize();
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_Texture_GetMipmapCount(void * jarg1) {
  int jresult ;
  Texture *arg1 = (Texture *) 0 ;
  std::shared_ptr< Texture > *smartarg1 = 0 ;
  int result;
  
  
  smartarg1 = (std::shared_ptr<  Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  result = (int)(arg1)->GetMipmapCount();
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_Texture_GetBlockSize(void * jarg1) {
  int jresult ;
  Texture *arg1 = (Texture *) 0 ;
  std::shared_ptr< Texture > *smartarg1 = 0 ;
  int result;
  
  
  smartarg1 = (std::shared_ptr<  Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  result = (int)(arg1)->GetBlockSize();
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_Texture_GetInternalFormat(void * jarg1) {
  int jresult ;
  Texture *arg1 = (Texture *) 0 ;
  std::shared_ptr< Texture > *smartarg1 = 0 ;
  ETextureFormat result;
  
  
  smartarg1 = (std::shared_ptr<  Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  result = (ETextureFormat)(arg1)->GetInternalFormat();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Texture_SetInternalFormat(void * jarg1, int jarg2) {
  Texture *arg1 = (Texture *) 0 ;
  ETextureFormat arg2 ;
  std::shared_ptr< Texture > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (ETextureFormat)jarg2; 
  (arg1)->SetInternalFormat(arg2);
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_Texture_GetSurface(void * jarg1) {
  int jresult ;
  Texture *arg1 = (Texture *) 0 ;
  std::shared_ptr< Texture > *smartarg1 = 0 ;
  ETextureSurface result;
  
  
  smartarg1 = (std::shared_ptr<  Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  result = (ETextureSurface)(arg1)->GetSurface();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Texture_SetSurface(void * jarg1, int jarg2) {
  Texture *arg1 = (Texture *) 0 ;
  ETextureSurface arg2 ;
  std::shared_ptr< Texture > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (ETextureSurface)jarg2; 
  (arg1)->SetSurface(arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_Texture_GetIsFlipped(void * jarg1) {
  unsigned int jresult ;
  Texture *arg1 = (Texture *) 0 ;
  std::shared_ptr< Texture const > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr< const Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  result = (bool)((Texture const *)arg1)->GetIsFlipped();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Texture(void * jarg1) {
  Texture *arg1 = (Texture *) 0 ;
  std::shared_ptr< Texture > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Texture > *)jarg1;
  arg1 = (Texture *)(smartarg1 ? smartarg1->get() : 0); 
  (void)arg1; delete smartarg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_ambient_set(void * jarg1, void * jarg2) {
  Material *arg1 = (Material *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->m_ambient = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Material_m_ambient_get(void * jarg1) {
  void * jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (CCMaths::Vector3 *)& ((arg1)->m_ambient);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_diffuse_set(void * jarg1, void * jarg2) {
  Material *arg1 = (Material *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->m_diffuse = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Material_m_diffuse_get(void * jarg1) {
  void * jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (CCMaths::Vector3 *)& ((arg1)->m_diffuse);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_specular_set(void * jarg1, void * jarg2) {
  Material *arg1 = (Material *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->m_specular = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Material_m_specular_get(void * jarg1) {
  void * jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (CCMaths::Vector3 *)& ((arg1)->m_specular);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_emissive_set(void * jarg1, void * jarg2) {
  Material *arg1 = (Material *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->m_emissive = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Material_m_emissive_get(void * jarg1) {
  void * jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (CCMaths::Vector3 *)& ((arg1)->m_emissive);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_shininess_set(void * jarg1, float jarg2) {
  Material *arg1 = (Material *) 0 ;
  float arg2 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->m_shininess = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Material_m_shininess_get(void * jarg1) {
  float jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  float result;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (float) ((arg1)->m_shininess);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_hasNormal_set(void * jarg1, unsigned int jarg2) {
  Material *arg1 = (Material *) 0 ;
  bool arg2 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = jarg2 ? true : false; 
  if (arg1) (arg1)->m_hasNormal = arg2;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_Material_m_hasNormal_get(void * jarg1) {
  unsigned int jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (bool) ((arg1)->m_hasNormal);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_specularFactor_set(void * jarg1, float jarg2) {
  Material *arg1 = (Material *) 0 ;
  float arg2 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->m_specularFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Material_m_specularFactor_get(void * jarg1) {
  float jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  float result;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (float) ((arg1)->m_specularFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_metallicFactor_set(void * jarg1, float jarg2) {
  Material *arg1 = (Material *) 0 ;
  float arg2 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->m_metallicFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Material_m_metallicFactor_get(void * jarg1) {
  float jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  float result;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (float) ((arg1)->m_metallicFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_roughnessFactor_set(void * jarg1, float jarg2) {
  Material *arg1 = (Material *) 0 ;
  float arg2 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->m_roughnessFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Material_m_roughnessFactor_get(void * jarg1) {
  float jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  float result;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (float) ((arg1)->m_roughnessFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_ao_set(void * jarg1, float jarg2) {
  Material *arg1 = (Material *) 0 ;
  float arg2 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->m_ao = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Material_m_ao_get(void * jarg1) {
  float jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  float result;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (float) ((arg1)->m_ao);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_clearCoatFactor_set(void * jarg1, float jarg2) {
  Material *arg1 = (Material *) 0 ;
  float arg2 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->m_clearCoatFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Material_m_clearCoatFactor_get(void * jarg1) {
  float jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  float result;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (float) ((arg1)->m_clearCoatFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_m_clearCoatRoughnessFactor_set(void * jarg1, float jarg2) {
  Material *arg1 = (Material *) 0 ;
  float arg2 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->m_clearCoatRoughnessFactor = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Material_m_clearCoatRoughnessFactor_get(void * jarg1) {
  float jresult ;
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  float result;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  result = (float) ((arg1)->m_clearCoatRoughnessFactor);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_SetTexture__SWIG_0(void * jarg1, int jarg2, void * jarg3) {
  Material *arg1 = (Material *) 0 ;
  ETextureType arg2 ;
  std::shared_ptr< Texture > *arg3 = 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  std::shared_ptr< Texture > tempnull3 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (ETextureType)jarg2; 
  arg3 = jarg3 ? (std::shared_ptr< Texture > *)jarg3 : &tempnull3; 
  (arg1)->SetTexture(arg2,(std::shared_ptr< Texture > const &)*arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Material_SetTexture__SWIG_1(void * jarg1, int jarg2, char * jarg3) {
  Material *arg1 = (Material *) 0 ;
  ETextureType arg2 ;
  char *arg3 = (char *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (ETextureType)jarg2; 
  arg3 = (char *)jarg3; 
  (arg1)->SetTexture(arg2,(char const *)arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Material(void * jarg1) {
  Material *arg1 = (Material *) 0 ;
  std::shared_ptr< Material > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  Material > *)jarg1;
  arg1 = (Material *)(smartarg1 ? smartarg1->get() : 0); 
  (void)arg1; delete smartarg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_MeshRenderer_m_material_get(void * jarg1) {
  void * jresult ;
  MeshRenderer *arg1 = (MeshRenderer *) 0 ;
  std::shared_ptr< Material > *result = 0 ;
  
  arg1 = (MeshRenderer *)jarg1; 
  result = (std::shared_ptr< Material > *) & ((arg1)->m_material);
  jresult = *result ? new std::shared_ptr< Material >(*result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_MeshRenderer_m_mesh_get(void * jarg1) {
  void * jresult ;
  MeshRenderer *arg1 = (MeshRenderer *) 0 ;
  std::shared_ptr< Mesh > *result = 0 ;
  
  arg1 = (MeshRenderer *)jarg1; 
  result = (std::shared_ptr< Mesh > *) & ((arg1)->m_mesh);
  jresult = *result ? new std::shared_ptr< Mesh >(*result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_MeshRenderer_m_transform_get(void * jarg1) {
  void * jresult ;
  MeshRenderer *arg1 = (MeshRenderer *) 0 ;
  Transform *result = 0 ;
  
  arg1 = (MeshRenderer *)jarg1; 
  result = (Transform *) ((arg1)->m_transform);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_MeshRenderer_SetMesh(void * jarg1, void * jarg2) {
  MeshRenderer *arg1 = (MeshRenderer *) 0 ;
  std::shared_ptr< Mesh > arg2 ;
  
  arg1 = (MeshRenderer *)jarg1; 
  if (jarg2) arg2 = *(std::shared_ptr< Mesh > *)jarg2; 
  (arg1)->SetMesh(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_MeshRenderer_RemoveMesh(void * jarg1) {
  MeshRenderer *arg1 = (MeshRenderer *) 0 ;
  
  arg1 = (MeshRenderer *)jarg1; 
  (arg1)->RemoveMesh();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_MeshRenderer_SetMaterialFromPath(void * jarg1, char * jarg2) {
  MeshRenderer *arg1 = (MeshRenderer *) 0 ;
  std::string arg2 ;
  
  arg1 = (MeshRenderer *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->SetMaterialFromPath(arg2);
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CCEngine_MeshRenderer_GetMaterialPath(void * jarg1) {
  char * jresult ;
  MeshRenderer *arg1 = (MeshRenderer *) 0 ;
  std::string result;
  
  arg1 = (MeshRenderer *)jarg1; 
  result = (arg1)->GetMaterialPath();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_MeshRenderer_SetMaterial(void * jarg1, void * jarg2) {
  MeshRenderer *arg1 = (MeshRenderer *) 0 ;
  std::shared_ptr< Material > arg2 ;
  
  arg1 = (MeshRenderer *)jarg1; 
  if (jarg2) arg2 = *(std::shared_ptr< Material > *)jarg2; 
  (arg1)->SetMaterial(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_MeshRenderer_RemoveMaterial(void * jarg1) {
  MeshRenderer *arg1 = (MeshRenderer *) 0 ;
  
  arg1 = (MeshRenderer *)jarg1; 
  (arg1)->RemoveMaterial();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_MeshRenderer(void * jarg1) {
  MeshRenderer *arg1 = (MeshRenderer *) 0 ;
  
  arg1 = (MeshRenderer *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRenderer_SetMeshFromPath(void * jarg1, char * jarg2) {
  ModelRenderer *arg1 = (ModelRenderer *) 0 ;
  std::string arg2 ;
  
  arg1 = (ModelRenderer *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->SetMeshFromPath(arg2);
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CCEngine_ModelRenderer_GetMeshPath(void * jarg1) {
  char * jresult ;
  ModelRenderer *arg1 = (ModelRenderer *) 0 ;
  std::string result;
  
  arg1 = (ModelRenderer *)jarg1; 
  result = (arg1)->GetMeshPath();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRenderer_LoadModelFromPath(void * jarg1, char * jarg2) {
  ModelRenderer *arg1 = (ModelRenderer *) 0 ;
  std::string arg2 ;
  
  arg1 = (ModelRenderer *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->LoadModelFromPath(arg2);
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CCEngine_ModelRenderer_GetModelPath(void * jarg1) {
  char * jresult ;
  ModelRenderer *arg1 = (ModelRenderer *) 0 ;
  std::string result;
  
  arg1 = (ModelRenderer *)jarg1; 
  result = (arg1)->GetModelPath();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_ModelRenderer(void * jarg1) {
  ModelRenderer *arg1 = (ModelRenderer *) 0 ;
  
  arg1 = (ModelRenderer *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_Clear(void * jarg1) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_Add(void * jarg1, void * jarg2) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  CameraComponent **arg2 = 0 ;
  CameraComponent *temp2 = 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  temp2 = (CameraComponent *)jarg2;
  arg2 = (CameraComponent **)&temp2; 
  (arg1)->push_back((CameraComponent *const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  std::vector< CameraComponent * >::size_type result;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  result = ((std::vector< CameraComponent * > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  std::vector< CameraComponent * >::size_type result;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  result = ((std::vector< CameraComponent * > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  std::vector< CameraComponent * >::size_type arg2 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (std::vector< CameraComponent * >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_CameraComponentVector__SWIG_0() {
  void * jresult ;
  std::vector< CameraComponent * > *result = 0 ;
  
  result = (std::vector< CameraComponent * > *)new std::vector< CameraComponent * >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_CameraComponentVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< CameraComponent * > *arg1 = 0 ;
  std::vector< CameraComponent * > *result = 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CameraComponent * > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< CameraComponent * > *)new std::vector< CameraComponent * >((std::vector< CameraComponent * > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_CameraComponentVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< CameraComponent * > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< CameraComponent * > *)new_std_vector_Sl_CameraComponent_Sm__Sg___SWIG_2(arg1);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  int arg2 ;
  CameraComponent *result = 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (CameraComponent *)std_vector_Sl_CameraComponent_Sm__Sg__getitemcopy(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  int arg2 ;
  std::vector< CameraComponent * >::value_type *result = 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CameraComponent * >::value_type *) &std_vector_Sl_CameraComponent_Sm__Sg__getitem(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  int arg2 ;
  CameraComponent **arg3 = 0 ;
  CameraComponent *temp3 = 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (CameraComponent *)jarg3;
  arg3 = (CameraComponent **)&temp3; 
  try {
    std_vector_Sl_CameraComponent_Sm__Sg__setitem(arg1,arg2,(CameraComponent *const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  std::vector< CameraComponent * > *arg2 = 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (std::vector< CameraComponent * > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CameraComponent * > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_CameraComponent_Sm__Sg__AddRange(arg1,(std::vector< CameraComponent * > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< CameraComponent * > *result = 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< CameraComponent * > *)std_vector_Sl_CameraComponent_Sm__Sg__GetRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  int arg2 ;
  CameraComponent **arg3 = 0 ;
  CameraComponent *temp3 = 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (CameraComponent *)jarg3;
  arg3 = (CameraComponent **)&temp3; 
  try {
    std_vector_Sl_CameraComponent_Sm__Sg__Insert(arg1,arg2,(CameraComponent *const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  int arg2 ;
  std::vector< CameraComponent * > *arg3 = 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CameraComponent * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CameraComponent * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CameraComponent_Sm__Sg__InsertRange(arg1,arg2,(std::vector< CameraComponent * > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_CameraComponent_Sm__Sg__RemoveAt(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CameraComponent_Sm__Sg__RemoveRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  CameraComponent **arg1 = 0 ;
  int arg2 ;
  CameraComponent *temp1 = 0 ;
  std::vector< CameraComponent * > *result = 0 ;
  
  temp1 = (CameraComponent *)jarg1;
  arg1 = (CameraComponent **)&temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< CameraComponent * > *)std_vector_Sl_CameraComponent_Sm__Sg__Repeat((CameraComponent *const &)*arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  std_vector_Sl_CameraComponent_Sm__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_CameraComponent_Sm__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  int arg2 ;
  std::vector< CameraComponent * > *arg3 = 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< CameraComponent * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< CameraComponent * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_CameraComponent_Sm__Sg__SetRange(arg1,arg2,(std::vector< CameraComponent * > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  CameraComponent **arg2 = 0 ;
  CameraComponent *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  temp2 = (CameraComponent *)jarg2;
  arg2 = (CameraComponent **)&temp2; 
  result = (bool)std_vector_Sl_CameraComponent_Sm__Sg__Contains(arg1,(CameraComponent *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  CameraComponent **arg2 = 0 ;
  CameraComponent *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  temp2 = (CameraComponent *)jarg2;
  arg2 = (CameraComponent **)&temp2; 
  result = (int)std_vector_Sl_CameraComponent_Sm__Sg__IndexOf(arg1,(CameraComponent *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  CameraComponent **arg2 = 0 ;
  CameraComponent *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  temp2 = (CameraComponent *)jarg2;
  arg2 = (CameraComponent **)&temp2; 
  result = (int)std_vector_Sl_CameraComponent_Sm__Sg__LastIndexOf(arg1,(CameraComponent *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_CameraComponentVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  CameraComponent **arg2 = 0 ;
  CameraComponent *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  temp2 = (CameraComponent *)jarg2;
  arg2 = (CameraComponent **)&temp2; 
  result = (bool)std_vector_Sl_CameraComponent_Sm__Sg__Remove(arg1,(CameraComponent *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_CameraComponentVector(void * jarg1) {
  std::vector< CameraComponent * > *arg1 = (std::vector< CameraComponent * > *) 0 ;
  
  arg1 = (std::vector< CameraComponent * > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_Clear(void * jarg1) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_Add(void * jarg1, void * jarg2) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  Transform **arg2 = 0 ;
  Transform *temp2 = 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  temp2 = (Transform *)jarg2;
  arg2 = (Transform **)&temp2; 
  (arg1)->push_back((Transform *const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CCEngine_TransformVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  std::vector< Transform * >::size_type result;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  result = ((std::vector< Transform * > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CCEngine_TransformVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  std::vector< Transform * >::size_type result;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  result = ((std::vector< Transform * > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  std::vector< Transform * >::size_type arg2 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (std::vector< Transform * >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_TransformVector__SWIG_0() {
  void * jresult ;
  std::vector< Transform * > *result = 0 ;
  
  result = (std::vector< Transform * > *)new std::vector< Transform * >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_TransformVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< Transform * > *arg1 = 0 ;
  std::vector< Transform * > *result = 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Transform * > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< Transform * > *)new std::vector< Transform * >((std::vector< Transform * > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_TransformVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< Transform * > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< Transform * > *)new_std_vector_Sl_Transform_Sm__Sg___SWIG_2(arg1);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_TransformVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  int arg2 ;
  Transform *result = 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (Transform *)std_vector_Sl_Transform_Sm__Sg__getitemcopy(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_TransformVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  int arg2 ;
  std::vector< Transform * >::value_type *result = 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< Transform * >::value_type *) &std_vector_Sl_Transform_Sm__Sg__getitem(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  int arg2 ;
  Transform **arg3 = 0 ;
  Transform *temp3 = 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (Transform *)jarg3;
  arg3 = (Transform **)&temp3; 
  try {
    std_vector_Sl_Transform_Sm__Sg__setitem(arg1,arg2,(Transform *const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  std::vector< Transform * > *arg2 = 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (std::vector< Transform * > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Transform * > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_Transform_Sm__Sg__AddRange(arg1,(std::vector< Transform * > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_TransformVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< Transform * > *result = 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< Transform * > *)std_vector_Sl_Transform_Sm__Sg__GetRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  int arg2 ;
  Transform **arg3 = 0 ;
  Transform *temp3 = 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (Transform *)jarg3;
  arg3 = (Transform **)&temp3; 
  try {
    std_vector_Sl_Transform_Sm__Sg__Insert(arg1,arg2,(Transform *const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  int arg2 ;
  std::vector< Transform * > *arg3 = 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Transform * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Transform * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Transform_Sm__Sg__InsertRange(arg1,arg2,(std::vector< Transform * > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_Transform_Sm__Sg__RemoveAt(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Transform_Sm__Sg__RemoveRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_TransformVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  Transform **arg1 = 0 ;
  int arg2 ;
  Transform *temp1 = 0 ;
  std::vector< Transform * > *result = 0 ;
  
  temp1 = (Transform *)jarg1;
  arg1 = (Transform **)&temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< Transform * > *)std_vector_Sl_Transform_Sm__Sg__Repeat((Transform *const &)*arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  std_vector_Sl_Transform_Sm__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Transform_Sm__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_TransformVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  int arg2 ;
  std::vector< Transform * > *arg3 = 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Transform * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Transform * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Transform_Sm__Sg__SetRange(arg1,arg2,(std::vector< Transform * > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_TransformVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  Transform **arg2 = 0 ;
  Transform *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  temp2 = (Transform *)jarg2;
  arg2 = (Transform **)&temp2; 
  result = (bool)std_vector_Sl_Transform_Sm__Sg__Contains(arg1,(Transform *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_TransformVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  Transform **arg2 = 0 ;
  Transform *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  temp2 = (Transform *)jarg2;
  arg2 = (Transform **)&temp2; 
  result = (int)std_vector_Sl_Transform_Sm__Sg__IndexOf(arg1,(Transform *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_TransformVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  Transform **arg2 = 0 ;
  Transform *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  temp2 = (Transform *)jarg2;
  arg2 = (Transform **)&temp2; 
  result = (int)std_vector_Sl_Transform_Sm__Sg__LastIndexOf(arg1,(Transform *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_TransformVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  Transform **arg2 = 0 ;
  Transform *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  temp2 = (Transform *)jarg2;
  arg2 = (Transform **)&temp2; 
  result = (bool)std_vector_Sl_Transform_Sm__Sg__Remove(arg1,(Transform *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_TransformVector(void * jarg1) {
  std::vector< Transform * > *arg1 = (std::vector< Transform * > *) 0 ;
  
  arg1 = (std::vector< Transform * > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_Clear(void * jarg1) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_Add(void * jarg1, void * jarg2) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  ScriptedBehaviour **arg2 = 0 ;
  ScriptedBehaviour *temp2 = 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  temp2 = (ScriptedBehaviour *)jarg2;
  arg2 = (ScriptedBehaviour **)&temp2; 
  (arg1)->push_back((ScriptedBehaviour *const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  std::vector< ScriptedBehaviour * >::size_type result;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  result = ((std::vector< ScriptedBehaviour * > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  std::vector< ScriptedBehaviour * >::size_type result;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  result = ((std::vector< ScriptedBehaviour * > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  std::vector< ScriptedBehaviour * >::size_type arg2 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (std::vector< ScriptedBehaviour * >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_ScriptedBehaviourVector__SWIG_0() {
  void * jresult ;
  std::vector< ScriptedBehaviour * > *result = 0 ;
  
  result = (std::vector< ScriptedBehaviour * > *)new std::vector< ScriptedBehaviour * >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_ScriptedBehaviourVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< ScriptedBehaviour * > *arg1 = 0 ;
  std::vector< ScriptedBehaviour * > *result = 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< ScriptedBehaviour * > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< ScriptedBehaviour * > *)new std::vector< ScriptedBehaviour * >((std::vector< ScriptedBehaviour * > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_ScriptedBehaviourVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< ScriptedBehaviour * > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< ScriptedBehaviour * > *)new_std_vector_Sl_ScriptedBehaviour_Sm__Sg___SWIG_2(arg1);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  int arg2 ;
  ScriptedBehaviour *result = 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (ScriptedBehaviour *)std_vector_Sl_ScriptedBehaviour_Sm__Sg__getitemcopy(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  int arg2 ;
  std::vector< ScriptedBehaviour * >::value_type *result = 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< ScriptedBehaviour * >::value_type *) &std_vector_Sl_ScriptedBehaviour_Sm__Sg__getitem(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  int arg2 ;
  ScriptedBehaviour **arg3 = 0 ;
  ScriptedBehaviour *temp3 = 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (ScriptedBehaviour *)jarg3;
  arg3 = (ScriptedBehaviour **)&temp3; 
  try {
    std_vector_Sl_ScriptedBehaviour_Sm__Sg__setitem(arg1,arg2,(ScriptedBehaviour *const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  std::vector< ScriptedBehaviour * > *arg2 = 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (std::vector< ScriptedBehaviour * > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< ScriptedBehaviour * > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_ScriptedBehaviour_Sm__Sg__AddRange(arg1,(std::vector< ScriptedBehaviour * > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< ScriptedBehaviour * > *result = 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< ScriptedBehaviour * > *)std_vector_Sl_ScriptedBehaviour_Sm__Sg__GetRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  int arg2 ;
  ScriptedBehaviour **arg3 = 0 ;
  ScriptedBehaviour *temp3 = 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (ScriptedBehaviour *)jarg3;
  arg3 = (ScriptedBehaviour **)&temp3; 
  try {
    std_vector_Sl_ScriptedBehaviour_Sm__Sg__Insert(arg1,arg2,(ScriptedBehaviour *const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  int arg2 ;
  std::vector< ScriptedBehaviour * > *arg3 = 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< ScriptedBehaviour * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< ScriptedBehaviour * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_ScriptedBehaviour_Sm__Sg__InsertRange(arg1,arg2,(std::vector< ScriptedBehaviour * > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_ScriptedBehaviour_Sm__Sg__RemoveAt(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_ScriptedBehaviour_Sm__Sg__RemoveRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  ScriptedBehaviour **arg1 = 0 ;
  int arg2 ;
  ScriptedBehaviour *temp1 = 0 ;
  std::vector< ScriptedBehaviour * > *result = 0 ;
  
  temp1 = (ScriptedBehaviour *)jarg1;
  arg1 = (ScriptedBehaviour **)&temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< ScriptedBehaviour * > *)std_vector_Sl_ScriptedBehaviour_Sm__Sg__Repeat((ScriptedBehaviour *const &)*arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  std_vector_Sl_ScriptedBehaviour_Sm__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_ScriptedBehaviour_Sm__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  int arg2 ;
  std::vector< ScriptedBehaviour * > *arg3 = 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< ScriptedBehaviour * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< ScriptedBehaviour * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_ScriptedBehaviour_Sm__Sg__SetRange(arg1,arg2,(std::vector< ScriptedBehaviour * > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  ScriptedBehaviour **arg2 = 0 ;
  ScriptedBehaviour *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  temp2 = (ScriptedBehaviour *)jarg2;
  arg2 = (ScriptedBehaviour **)&temp2; 
  result = (bool)std_vector_Sl_ScriptedBehaviour_Sm__Sg__Contains(arg1,(ScriptedBehaviour *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  ScriptedBehaviour **arg2 = 0 ;
  ScriptedBehaviour *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  temp2 = (ScriptedBehaviour *)jarg2;
  arg2 = (ScriptedBehaviour **)&temp2; 
  result = (int)std_vector_Sl_ScriptedBehaviour_Sm__Sg__IndexOf(arg1,(ScriptedBehaviour *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  ScriptedBehaviour **arg2 = 0 ;
  ScriptedBehaviour *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  temp2 = (ScriptedBehaviour *)jarg2;
  arg2 = (ScriptedBehaviour **)&temp2; 
  result = (int)std_vector_Sl_ScriptedBehaviour_Sm__Sg__LastIndexOf(arg1,(ScriptedBehaviour *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviourVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  ScriptedBehaviour **arg2 = 0 ;
  ScriptedBehaviour *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  temp2 = (ScriptedBehaviour *)jarg2;
  arg2 = (ScriptedBehaviour **)&temp2; 
  result = (bool)std_vector_Sl_ScriptedBehaviour_Sm__Sg__Remove(arg1,(ScriptedBehaviour *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_ScriptedBehaviourVector(void * jarg1) {
  std::vector< ScriptedBehaviour * > *arg1 = (std::vector< ScriptedBehaviour * > *) 0 ;
  
  arg1 = (std::vector< ScriptedBehaviour * > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_Clear(void * jarg1) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_Add(void * jarg1, void * jarg2) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  ModelRenderer **arg2 = 0 ;
  ModelRenderer *temp2 = 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  temp2 = (ModelRenderer *)jarg2;
  arg2 = (ModelRenderer **)&temp2; 
  (arg1)->push_back((ModelRenderer *const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  std::vector< ModelRenderer * >::size_type result;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  result = ((std::vector< ModelRenderer * > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  std::vector< ModelRenderer * >::size_type result;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  result = ((std::vector< ModelRenderer * > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  std::vector< ModelRenderer * >::size_type arg2 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (std::vector< ModelRenderer * >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_ModelRendererVector__SWIG_0() {
  void * jresult ;
  std::vector< ModelRenderer * > *result = 0 ;
  
  result = (std::vector< ModelRenderer * > *)new std::vector< ModelRenderer * >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_ModelRendererVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< ModelRenderer * > *arg1 = 0 ;
  std::vector< ModelRenderer * > *result = 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< ModelRenderer * > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< ModelRenderer * > *)new std::vector< ModelRenderer * >((std::vector< ModelRenderer * > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_ModelRendererVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< ModelRenderer * > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< ModelRenderer * > *)new_std_vector_Sl_ModelRenderer_Sm__Sg___SWIG_2(arg1);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  int arg2 ;
  ModelRenderer *result = 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (ModelRenderer *)std_vector_Sl_ModelRenderer_Sm__Sg__getitemcopy(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  int arg2 ;
  std::vector< ModelRenderer * >::value_type *result = 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< ModelRenderer * >::value_type *) &std_vector_Sl_ModelRenderer_Sm__Sg__getitem(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  int arg2 ;
  ModelRenderer **arg3 = 0 ;
  ModelRenderer *temp3 = 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (ModelRenderer *)jarg3;
  arg3 = (ModelRenderer **)&temp3; 
  try {
    std_vector_Sl_ModelRenderer_Sm__Sg__setitem(arg1,arg2,(ModelRenderer *const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  std::vector< ModelRenderer * > *arg2 = 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (std::vector< ModelRenderer * > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< ModelRenderer * > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_ModelRenderer_Sm__Sg__AddRange(arg1,(std::vector< ModelRenderer * > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< ModelRenderer * > *result = 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< ModelRenderer * > *)std_vector_Sl_ModelRenderer_Sm__Sg__GetRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  int arg2 ;
  ModelRenderer **arg3 = 0 ;
  ModelRenderer *temp3 = 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (ModelRenderer *)jarg3;
  arg3 = (ModelRenderer **)&temp3; 
  try {
    std_vector_Sl_ModelRenderer_Sm__Sg__Insert(arg1,arg2,(ModelRenderer *const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  int arg2 ;
  std::vector< ModelRenderer * > *arg3 = 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< ModelRenderer * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< ModelRenderer * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_ModelRenderer_Sm__Sg__InsertRange(arg1,arg2,(std::vector< ModelRenderer * > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_ModelRenderer_Sm__Sg__RemoveAt(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_ModelRenderer_Sm__Sg__RemoveRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  ModelRenderer **arg1 = 0 ;
  int arg2 ;
  ModelRenderer *temp1 = 0 ;
  std::vector< ModelRenderer * > *result = 0 ;
  
  temp1 = (ModelRenderer *)jarg1;
  arg1 = (ModelRenderer **)&temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< ModelRenderer * > *)std_vector_Sl_ModelRenderer_Sm__Sg__Repeat((ModelRenderer *const &)*arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  std_vector_Sl_ModelRenderer_Sm__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_ModelRenderer_Sm__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  int arg2 ;
  std::vector< ModelRenderer * > *arg3 = 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< ModelRenderer * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< ModelRenderer * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_ModelRenderer_Sm__Sg__SetRange(arg1,arg2,(std::vector< ModelRenderer * > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  ModelRenderer **arg2 = 0 ;
  ModelRenderer *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  temp2 = (ModelRenderer *)jarg2;
  arg2 = (ModelRenderer **)&temp2; 
  result = (bool)std_vector_Sl_ModelRenderer_Sm__Sg__Contains(arg1,(ModelRenderer *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  ModelRenderer **arg2 = 0 ;
  ModelRenderer *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  temp2 = (ModelRenderer *)jarg2;
  arg2 = (ModelRenderer **)&temp2; 
  result = (int)std_vector_Sl_ModelRenderer_Sm__Sg__IndexOf(arg1,(ModelRenderer *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  ModelRenderer **arg2 = 0 ;
  ModelRenderer *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  temp2 = (ModelRenderer *)jarg2;
  arg2 = (ModelRenderer **)&temp2; 
  result = (int)std_vector_Sl_ModelRenderer_Sm__Sg__LastIndexOf(arg1,(ModelRenderer *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_ModelRendererVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  ModelRenderer **arg2 = 0 ;
  ModelRenderer *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  temp2 = (ModelRenderer *)jarg2;
  arg2 = (ModelRenderer **)&temp2; 
  result = (bool)std_vector_Sl_ModelRenderer_Sm__Sg__Remove(arg1,(ModelRenderer *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_ModelRendererVector(void * jarg1) {
  std::vector< ModelRenderer * > *arg1 = (std::vector< ModelRenderer * > *) 0 ;
  
  arg1 = (std::vector< ModelRenderer * > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Entity_m_cell_set(void * jarg1, void * jarg2) {
  Entity *arg1 = (Entity *) 0 ;
  Cell *arg2 = (Cell *) 0 ;
  
  arg1 = (Entity *)jarg1; 
  arg2 = (Cell *)jarg2; 
  if (arg1) (arg1)->m_cell = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_m_cell_get(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  Cell *result = 0 ;
  
  arg1 = (Entity *)jarg1; 
  result = (Cell *) ((arg1)->m_cell);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Entity(void * jarg1) {
  Entity *arg1 = (Entity *) 0 ;
  
  arg1 = (Entity *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Entity_Destroy(void * jarg1) {
  Entity *arg1 = (Entity *) 0 ;
  
  arg1 = (Entity *)jarg1; 
  (arg1)->Destroy();
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CCEngine_Entity_GetName(void * jarg1) {
  char * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  std::string result;
  
  arg1 = (Entity *)jarg1; 
  result = (arg1)->GetName();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_GetCameraComponent(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  CameraComponent *result = 0 ;
  
  arg1 = (Entity *)jarg1; 
  result = (CameraComponent *)(arg1)->SWIGTEMPLATEDISAMBIGUATOR GetBehaviour< CameraComponent >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_AddCameraComponent(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  CameraComponent *result = 0 ;
  
  arg1 = (Entity *)jarg1; 
  result = (CameraComponent *)(arg1)->SWIGTEMPLATEDISAMBIGUATOR AddBehaviour< CameraComponent >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_GetAllOfCameraComponent(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  std::vector< CameraComponent * > result;
  
  arg1 = (Entity *)jarg1; 
  result = (arg1)->SWIGTEMPLATEDISAMBIGUATOR GetBehavioursOfType< CameraComponent >();
  jresult = new std::vector< CameraComponent * >((const std::vector< CameraComponent * > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_GetScriptedBehaviour(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  ScriptedBehaviour *result = 0 ;
  
  arg1 = (Entity *)jarg1; 
  result = (ScriptedBehaviour *)(arg1)->SWIGTEMPLATEDISAMBIGUATOR GetBehaviour< ScriptedBehaviour >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_AddScriptedBehaviour(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  ScriptedBehaviour *result = 0 ;
  
  arg1 = (Entity *)jarg1; 
  result = (ScriptedBehaviour *)(arg1)->SWIGTEMPLATEDISAMBIGUATOR AddBehaviour< ScriptedBehaviour >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_GetAllOfScriptedBehaviour(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  std::vector< ScriptedBehaviour * > result;
  
  arg1 = (Entity *)jarg1; 
  result = (arg1)->SWIGTEMPLATEDISAMBIGUATOR GetBehavioursOfType< ScriptedBehaviour >();
  jresult = new std::vector< ScriptedBehaviour * >((const std::vector< ScriptedBehaviour * > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_GetTransform(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  Transform *result = 0 ;
  
  arg1 = (Entity *)jarg1; 
  result = (Transform *)(arg1)->SWIGTEMPLATEDISAMBIGUATOR GetBehaviour< Transform >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_AddTransform(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  Transform *result = 0 ;
  
  arg1 = (Entity *)jarg1; 
  result = (Transform *)(arg1)->SWIGTEMPLATEDISAMBIGUATOR AddBehaviour< Transform >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_GetAllOfTransform(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  std::vector< Transform * > result;
  
  arg1 = (Entity *)jarg1; 
  result = (arg1)->SWIGTEMPLATEDISAMBIGUATOR GetBehavioursOfType< Transform >();
  jresult = new std::vector< Transform * >((const std::vector< Transform * > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_GetModelRenderer(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  ModelRenderer *result = 0 ;
  
  arg1 = (Entity *)jarg1; 
  result = (ModelRenderer *)(arg1)->SWIGTEMPLATEDISAMBIGUATOR GetBehaviour< ModelRenderer >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_AddModelRenderer(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  ModelRenderer *result = 0 ;
  
  arg1 = (Entity *)jarg1; 
  result = (ModelRenderer *)(arg1)->SWIGTEMPLATEDISAMBIGUATOR AddBehaviour< ModelRenderer >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Entity_GetAllOfModelRenderer(void * jarg1) {
  void * jresult ;
  Entity *arg1 = (Entity *) 0 ;
  std::vector< ModelRenderer * > result;
  
  arg1 = (Entity *)jarg1; 
  result = (arg1)->SWIGTEMPLATEDISAMBIGUATOR GetBehavioursOfType< ModelRenderer >();
  jresult = new std::vector< ModelRenderer * >((const std::vector< ModelRenderer * > &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_Clear(void * jarg1) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_Add(void * jarg1, void * jarg2) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  Entity **arg2 = 0 ;
  Entity *temp2 = 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  temp2 = (Entity *)jarg2;
  arg2 = (Entity **)&temp2; 
  (arg1)->push_back((Entity *const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CCEngine_EntityVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  std::vector< Entity * >::size_type result;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  result = ((std::vector< Entity * > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_CCEngine_EntityVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  std::vector< Entity * >::size_type result;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  result = ((std::vector< Entity * > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  std::vector< Entity * >::size_type arg2 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (std::vector< Entity * >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_EntityVector__SWIG_0() {
  void * jresult ;
  std::vector< Entity * > *result = 0 ;
  
  result = (std::vector< Entity * > *)new std::vector< Entity * >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_EntityVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< Entity * > *arg1 = 0 ;
  std::vector< Entity * > *result = 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Entity * > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< Entity * > *)new std::vector< Entity * >((std::vector< Entity * > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_EntityVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< Entity * > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< Entity * > *)new_std_vector_Sl_Entity_Sm__Sg___SWIG_2(arg1);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_EntityVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  int arg2 ;
  Entity *result = 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (Entity *)std_vector_Sl_Entity_Sm__Sg__getitemcopy(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_EntityVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  int arg2 ;
  std::vector< Entity * >::value_type *result = 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< Entity * >::value_type *) &std_vector_Sl_Entity_Sm__Sg__getitem(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)*result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  int arg2 ;
  Entity **arg3 = 0 ;
  Entity *temp3 = 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (Entity *)jarg3;
  arg3 = (Entity **)&temp3; 
  try {
    std_vector_Sl_Entity_Sm__Sg__setitem(arg1,arg2,(Entity *const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  std::vector< Entity * > *arg2 = 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (std::vector< Entity * > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Entity * > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_Entity_Sm__Sg__AddRange(arg1,(std::vector< Entity * > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_EntityVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< Entity * > *result = 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< Entity * > *)std_vector_Sl_Entity_Sm__Sg__GetRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  int arg2 ;
  Entity **arg3 = 0 ;
  Entity *temp3 = 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (Entity *)jarg3;
  arg3 = (Entity **)&temp3; 
  try {
    std_vector_Sl_Entity_Sm__Sg__Insert(arg1,arg2,(Entity *const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  int arg2 ;
  std::vector< Entity * > *arg3 = 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Entity * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Entity * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Entity_Sm__Sg__InsertRange(arg1,arg2,(std::vector< Entity * > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_Entity_Sm__Sg__RemoveAt(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Entity_Sm__Sg__RemoveRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_EntityVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  Entity **arg1 = 0 ;
  int arg2 ;
  Entity *temp1 = 0 ;
  std::vector< Entity * > *result = 0 ;
  
  temp1 = (Entity *)jarg1;
  arg1 = (Entity **)&temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< Entity * > *)std_vector_Sl_Entity_Sm__Sg__Repeat((Entity *const &)*arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  std_vector_Sl_Entity_Sm__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_Entity_Sm__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_EntityVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  int arg2 ;
  std::vector< Entity * > *arg3 = 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< Entity * > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< Entity * > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_Entity_Sm__Sg__SetRange(arg1,arg2,(std::vector< Entity * > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_EntityVector_Contains(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  Entity **arg2 = 0 ;
  Entity *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  temp2 = (Entity *)jarg2;
  arg2 = (Entity **)&temp2; 
  result = (bool)std_vector_Sl_Entity_Sm__Sg__Contains(arg1,(Entity *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_EntityVector_IndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  Entity **arg2 = 0 ;
  Entity *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  temp2 = (Entity *)jarg2;
  arg2 = (Entity **)&temp2; 
  result = (int)std_vector_Sl_Entity_Sm__Sg__IndexOf(arg1,(Entity *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_CCEngine_EntityVector_LastIndexOf(void * jarg1, void * jarg2) {
  int jresult ;
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  Entity **arg2 = 0 ;
  Entity *temp2 = 0 ;
  int result;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  temp2 = (Entity *)jarg2;
  arg2 = (Entity **)&temp2; 
  result = (int)std_vector_Sl_Entity_Sm__Sg__LastIndexOf(arg1,(Entity *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_EntityVector_Remove(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  Entity **arg2 = 0 ;
  Entity *temp2 = 0 ;
  bool result;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  temp2 = (Entity *)jarg2;
  arg2 = (Entity **)&temp2; 
  result = (bool)std_vector_Sl_Entity_Sm__Sg__Remove(arg1,(Entity *const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_EntityVector(void * jarg1) {
  std::vector< Entity * > *arg1 = (std::vector< Entity * > *) 0 ;
  
  arg1 = (std::vector< Entity * > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Cell_Initialize(void * jarg1) {
  Cell *arg1 = (Cell *) 0 ;
  
  arg1 = (Cell *)jarg1; 
  (arg1)->Initialize();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Cell_GetEntities(void * jarg1) {
  void * jresult ;
  Cell *arg1 = (Cell *) 0 ;
  std::vector< Entity * > *result = 0 ;
  
  arg1 = (Cell *)jarg1; 
  result = (std::vector< Entity * > *) &(arg1)->GetEntities();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Cell_SetName(void * jarg1, char * jarg2) {
  Cell *arg1 = (Cell *) 0 ;
  std::string *arg2 = 0 ;
  
  arg1 = (Cell *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
    return ;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  (arg1)->SetName((std::string const &)*arg2);
}


SWIGEXPORT char * SWIGSTDCALL CSharp_CCEngine_Cell_GetName(void * jarg1) {
  char * jresult ;
  Cell *arg1 = (Cell *) 0 ;
  std::string *result = 0 ;
  
  arg1 = (Cell *)jarg1; 
  result = (std::string *) &(arg1)->GetName();
  jresult = SWIG_csharp_string_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Cell(void * jarg1) {
  Cell *arg1 = (Cell *) 0 ;
  
  arg1 = (Cell *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_PhysicActor_AddForce(void * jarg1, void * jarg2, int jarg3) {
  PhysicActor *arg1 = (PhysicActor *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  EForceMode arg3 ;
  
  arg1 = (PhysicActor *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (EForceMode)jarg3; 
  (arg1)->AddForce((CCMaths::Vector3 const &)*arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_PhysicActor_AddTorque(void * jarg1, void * jarg2, int jarg3) {
  PhysicActor *arg1 = (PhysicActor *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  EForceMode arg3 ;
  
  arg1 = (PhysicActor *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (EForceMode)jarg3; 
  (arg1)->AddTorque((CCMaths::Vector3 const &)*arg2,arg3);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_PhysicActor_Raycast(void * jarg1, void * jarg2, void * jarg3, float jarg4) {
  void * jresult ;
  PhysicActor *arg1 = (PhysicActor *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Vector3 *arg3 = 0 ;
  float arg4 ;
  RaycastHit result;
  
  arg1 = (PhysicActor *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (CCMaths::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  result = (arg1)->Raycast((CCMaths::Vector3 const &)*arg2,(CCMaths::Vector3 const &)*arg3,arg4);
  jresult = new RaycastHit((const RaycastHit &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_PhysicActor_SetEnabled(void * jarg1, unsigned int jarg2) {
  PhysicActor *arg1 = (PhysicActor *) 0 ;
  bool *arg2 = 0 ;
  bool temp2 ;
  
  arg1 = (PhysicActor *)jarg1; 
  temp2 = jarg2 ? true : false; 
  arg2 = &temp2; 
  (arg1)->SetEnabled((bool const &)*arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_PhysicActor_GetEnabled(void * jarg1) {
  unsigned int jresult ;
  PhysicActor *arg1 = (PhysicActor *) 0 ;
  bool result;
  
  arg1 = (PhysicActor *)jarg1; 
  result = (bool)(arg1)->GetEnabled();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_PhysicActor_m_owner_get(void * jarg1) {
  void * jresult ;
  PhysicActor *arg1 = (PhysicActor *) 0 ;
  Entity *result = 0 ;
  
  arg1 = (PhysicActor *)jarg1; 
  result = (Entity *) ((arg1)->m_owner);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_PhysicActor_HasRigidbody(void * jarg1) {
  unsigned int jresult ;
  PhysicActor *arg1 = (PhysicActor *) 0 ;
  bool result;
  
  arg1 = (PhysicActor *)jarg1; 
  result = (bool)(arg1)->HasRigidbody();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_PhysicActor_HasColliders(void * jarg1) {
  unsigned int jresult ;
  PhysicActor *arg1 = (PhysicActor *) 0 ;
  bool result;
  
  arg1 = (PhysicActor *)jarg1; 
  result = (bool)(arg1)->HasColliders();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_PhysicActor(void * jarg1) {
  PhysicActor *arg1 = (PhysicActor *) 0 ;
  
  arg1 = (PhysicActor *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_RaycastHit_position_set(void * jarg1, void * jarg2) {
  RaycastHit *arg1 = (RaycastHit *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  
  arg1 = (RaycastHit *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->position = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_RaycastHit_position_get(void * jarg1) {
  void * jresult ;
  RaycastHit *arg1 = (RaycastHit *) 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (RaycastHit *)jarg1; 
  result = (CCMaths::Vector3 *)& ((arg1)->position);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_RaycastHit_normal_set(void * jarg1, void * jarg2) {
  RaycastHit *arg1 = (RaycastHit *) 0 ;
  CCMaths::Vector3 *arg2 = (CCMaths::Vector3 *) 0 ;
  
  arg1 = (RaycastHit *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2; 
  if (arg1) (arg1)->normal = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_RaycastHit_normal_get(void * jarg1) {
  void * jresult ;
  RaycastHit *arg1 = (RaycastHit *) 0 ;
  CCMaths::Vector3 *result = 0 ;
  
  arg1 = (RaycastHit *)jarg1; 
  result = (CCMaths::Vector3 *)& ((arg1)->normal);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_RaycastHit_distance_set(void * jarg1, float jarg2) {
  RaycastHit *arg1 = (RaycastHit *) 0 ;
  float arg2 ;
  
  arg1 = (RaycastHit *)jarg1; 
  arg2 = (float)jarg2; 
  if (arg1) (arg1)->distance = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_RaycastHit_distance_get(void * jarg1) {
  float jresult ;
  RaycastHit *arg1 = (RaycastHit *) 0 ;
  float result;
  
  arg1 = (RaycastHit *)jarg1; 
  result = (float) ((arg1)->distance);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_RaycastHit_actor_set(void * jarg1, void * jarg2) {
  RaycastHit *arg1 = (RaycastHit *) 0 ;
  PhysicActor *arg2 = (PhysicActor *) 0 ;
  
  arg1 = (RaycastHit *)jarg1; 
  arg2 = (PhysicActor *)jarg2; 
  if (arg1) (arg1)->actor = arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_RaycastHit_actor_get(void * jarg1) {
  void * jresult ;
  RaycastHit *arg1 = (RaycastHit *) 0 ;
  PhysicActor *result = 0 ;
  
  arg1 = (RaycastHit *)jarg1; 
  result = (PhysicActor *) ((arg1)->actor);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_RaycastHit() {
  void * jresult ;
  RaycastHit *result = 0 ;
  
  result = (RaycastHit *)new RaycastHit();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_RaycastHit(void * jarg1) {
  RaycastHit *arg1 = (RaycastHit *) 0 ;
  
  arg1 = (RaycastHit *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_PhysicManager_GetInstance() {
  void * jresult ;
  PhysicManager *result = 0 ;
  
  result = (PhysicManager *)PhysicManager::GetInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_PhysicManager_FindActor(void * jarg1, void * jarg2) {
  void * jresult ;
  PhysicManager *arg1 = (PhysicManager *) 0 ;
  Entity *arg2 = 0 ;
  PhysicActor *result = 0 ;
  
  arg1 = (PhysicManager *)jarg1; 
  arg2 = (Entity *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Entity & type is null", 0);
    return 0;
  } 
  result = (PhysicActor *)(arg1)->FindActor(*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_PhysicManager_Raycast(void * jarg1, void * jarg2, void * jarg3, float jarg4) {
  void * jresult ;
  Cell *arg1 = 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  CCMaths::Vector3 *arg3 = 0 ;
  float arg4 ;
  RaycastHit result;
  
  arg1 = (Cell *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Cell & type is null", 0);
    return 0;
  } 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  arg3 = (CCMaths::Vector3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return 0;
  } 
  arg4 = (float)jarg4; 
  result = PhysicManager::Raycast(*arg1,(CCMaths::Vector3 const &)*arg2,(CCMaths::Vector3 const &)*arg3,arg4);
  jresult = new RaycastHit((const RaycastHit &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_PhysicManager_AddForce(void * jarg1, void * jarg2, int jarg3) {
  Entity *arg1 = (Entity *) 0 ;
  CCMaths::Vector3 *arg2 = 0 ;
  EForceMode arg3 ;
  
  arg1 = (Entity *)jarg1; 
  arg2 = (CCMaths::Vector3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "CCMaths::Vector3 const & type is null", 0);
    return ;
  } 
  arg3 = (EForceMode)jarg3; 
  PhysicManager::AddForce(arg1,(CCMaths::Vector3 const &)*arg2,arg3);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_PhysicManager() {
  void * jresult ;
  PhysicManager *result = 0 ;
  
  result = (PhysicManager *)new PhysicManager();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_PhysicManager(void * jarg1) {
  PhysicManager *arg1 = (PhysicManager *) 0 ;
  
  arg1 = (PhysicManager *)jarg1; 
  delete arg1;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_InputManager_GetKey__SWIG_0(int jarg1) {
  unsigned int jresult ;
  Keycode arg1 ;
  bool result;
  
  arg1 = (Keycode)jarg1; 
  result = (bool)InputManager::GetKey(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_InputManager_GetKeyDown__SWIG_0(int jarg1) {
  unsigned int jresult ;
  Keycode arg1 ;
  bool result;
  
  arg1 = (Keycode)jarg1; 
  result = (bool)InputManager::GetKeyDown(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_InputManager_GetKeyUp__SWIG_0(int jarg1) {
  unsigned int jresult ;
  Keycode arg1 ;
  bool result;
  
  arg1 = (Keycode)jarg1; 
  result = (bool)InputManager::GetKeyUp(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_InputManager_GetKey__SWIG_1(char * jarg1) {
  unsigned int jresult ;
  char *arg1 = (char *) 0 ;
  bool result;
  
  arg1 = (char *)jarg1; 
  result = (bool)InputManager::GetKey((char const *)arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_InputManager_GetKeyDown__SWIG_1(char * jarg1) {
  unsigned int jresult ;
  char *arg1 = (char *) 0 ;
  bool result;
  
  arg1 = (char *)jarg1; 
  result = (bool)InputManager::GetKeyDown((char const *)arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_InputManager_GetKeyUp__SWIG_1(char * jarg1) {
  unsigned int jresult ;
  char *arg1 = (char *) 0 ;
  bool result;
  
  arg1 = (char *)jarg1; 
  result = (bool)InputManager::GetKeyUp((char const *)arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_InputManager_GetAxis(char * jarg1) {
  float jresult ;
  char *arg1 = (char *) 0 ;
  float result;
  
  arg1 = (char *)jarg1; 
  result = (float)InputManager::GetAxis((char const *)arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_InputManager_GetMouseWheel() {
  void * jresult ;
  CCMaths::Vector2 result;
  
  result = InputManager::GetMouseWheel();
  jresult = new CCMaths::Vector2((const CCMaths::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_InputManager_GetMousePos() {
  void * jresult ;
  CCMaths::Vector2 result;
  
  result = InputManager::GetMousePos();
  jresult = new CCMaths::Vector2((const CCMaths::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_InputManager_GetMouseDelta() {
  void * jresult ;
  CCMaths::Vector2 result;
  
  result = InputManager::GetMouseDelta();
  jresult = new CCMaths::Vector2((const CCMaths::Vector2 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_InputManager(void * jarg1) {
  InputManager *arg1 = (InputManager *) 0 ;
  
  arg1 = (InputManager *)jarg1; 
  delete arg1;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_CCEngine_SceneManager_ChangeScene(char * jarg1) {
  unsigned int jresult ;
  char *arg1 = (char *) 0 ;
  bool result;
  
  arg1 = (char *)jarg1; 
  result = (bool)SceneManager::ChangeScene((char const *)arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_SceneManager(void * jarg1) {
  SceneManager *arg1 = (SceneManager *) 0 ;
  
  arg1 = (SceneManager *)jarg1; 
  delete arg1;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Time_GetDeltaTime() {
  float jresult ;
  float result;
  
  result = (float)TimeManager::GetDeltaTime();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Time_GetTimeScale() {
  float jresult ;
  float result;
  
  result = (float)TimeManager::GetTimeScale();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_CCEngine_Time_GetFixedDeltaTime() {
  float jresult ;
  float result;
  
  result = (float)TimeManager::GetFixedDeltaTime();
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_CCEngine_Time_GetElapsedTime() {
  double jresult ;
  double result;
  
  result = (double)TimeManager::GetElapsedTime();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Time_SetTimeScale(float jarg1) {
  float arg1 ;
  
  arg1 = (float)jarg1; 
  TimeManager::SetTimeScale(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Time_SetFixedDeltaTime(float jarg1) {
  float arg1 ;
  
  arg1 = (float)jarg1; 
  TimeManager::SetFixedDeltaTime(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Time(void * jarg1) {
  TimeManager *arg1 = (TimeManager *) 0 ;
  
  arg1 = (TimeManager *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_Debug_GetInstance() {
  void * jresult ;
  Debug *result = 0 ;
  
  result = (Debug *)Debug::GetInstance();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_Debug_AddLog(void * jarg1, int jarg2, char * jarg3, unsigned int jarg4, char * jarg5, char * jarg6) {
  Debug *arg1 = (Debug *) 0 ;
  ELogType arg2 ;
  char *arg3 = (char *) 0 ;
  unsigned int arg4 ;
  char *arg5 = (char *) 0 ;
  char *arg6 = (char *) 0 ;
  
  arg1 = (Debug *)jarg1; 
  arg2 = (ELogType)jarg2; 
  arg3 = (char *)jarg3; 
  arg4 = (unsigned int)jarg4; 
  arg5 = (char *)jarg5; 
  arg6 = (char *)jarg6; 
  (arg1)->AddLog(arg2,(char const *)arg3,arg4,(char const *)arg5,(char const *)arg6);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_CCEngine_new_Debug() {
  void * jresult ;
  Debug *result = 0 ;
  
  result = (Debug *)new Debug();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_CCEngine_delete_Debug(void * jarg1) {
  Debug *arg1 = (Debug *) 0 ;
  
  arg1 = (Debug *)jarg1; 
  delete arg1;
}


SWIGEXPORT Object * SWIGSTDCALL CSharp_CCEngine_Behaviour_SWIGUpcast(Behaviour *jarg1) {
    return (Object *)jarg1;
}

SWIGEXPORT Behaviour * SWIGSTDCALL CSharp_CCEngine_Transform_SWIGUpcast(Transform *jarg1) {
    return (Behaviour *)jarg1;
}

SWIGEXPORT Behaviour * SWIGSTDCALL CSharp_CCEngine_CameraComponent_SWIGUpcast(CameraComponent *jarg1) {
    return (Behaviour *)jarg1;
}

SWIGEXPORT Behaviour * SWIGSTDCALL CSharp_CCEngine_ScriptedBehaviour_SWIGUpcast(ScriptedBehaviour *jarg1) {
    return (Behaviour *)jarg1;
}

SWIGEXPORT Behaviour * SWIGSTDCALL CSharp_CCEngine_MeshRenderer_SWIGUpcast(MeshRenderer *jarg1) {
    return (Behaviour *)jarg1;
}

SWIGEXPORT MeshRenderer * SWIGSTDCALL CSharp_CCEngine_ModelRenderer_SWIGUpcast(ModelRenderer *jarg1) {
    return (MeshRenderer *)jarg1;
}

SWIGEXPORT Object * SWIGSTDCALL CSharp_CCEngine_Entity_SWIGUpcast(Entity *jarg1) {
    return (Object *)jarg1;
}

SWIGEXPORT Object * SWIGSTDCALL CSharp_CCEngine_Cell_SWIGUpcast(Cell *jarg1) {
    return (Object *)jarg1;
}

#ifdef __cplusplus
}
#endif

